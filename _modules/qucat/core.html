

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>qucat.core &mdash; qucat  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            qucat
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../citing.html">Citing this project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../API/index.html">List of functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contact.html">Contact</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../report_a_bug.html">Report a bug</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devs/index.html">Developer Guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">qucat</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">qucat.core</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for qucat.core</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.lambdify</span> <span class="kn">import</span> <span class="n">lambdify</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.polynomial.polynomial</span> <span class="kn">import</span> <span class="n">Polynomial</span> <span class="k">as</span> <span class="n">npPoly</span>
<span class="kn">from</span> <span class="nn">sympy.core.mul</span> <span class="kn">import</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Pow</span><span class="p">,</span> <span class="n">Add</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">floor</span><span class="p">,</span> <span class="n">factorial</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">subprocess</span> <span class="kn">import</span> <span class="n">run</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">._constants</span> <span class="kn">import</span> <span class="o">*</span>
    <span class="kn">from</span> <span class="nn">._utility</span> <span class="kn">import</span> <span class="o">*</span>
    <span class="kn">from</span> <span class="nn">.plotting_settings</span> <span class="kn">import</span> <span class="n">plotting_parameters_show</span><span class="p">,</span><span class="n">plotting_parameters_normal_modes</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># When running from source without pip installation</span>
    <span class="kn">from</span> <span class="nn">_constants</span> <span class="kn">import</span> <span class="o">*</span>
    <span class="kn">from</span> <span class="nn">_utility</span> <span class="kn">import</span> <span class="o">*</span>
    <span class="kn">from</span> <span class="nn">plotting_settings</span> <span class="kn">import</span> <span class="n">plotting_parameters_show</span><span class="p">,</span><span class="n">plotting_parameters_normal_modes</span>

<span class="n">PROFILING</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">timeit</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Decorator which prints the time </span>
<span class="sd">    a function took to execute.</span>
<span class="sd">    Only works the global variable PROFILING is set to True.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">timed</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="n">te</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">PROFILING</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;calling </span><span class="si">%r</span><span class="s1"> took </span><span class="si">%2.2f</span><span class="s1"> ms&#39;</span> <span class="o">%</span> \
                    <span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="p">(</span><span class="n">te</span> <span class="o">-</span> <span class="n">ts</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">timed</span>

<span class="k">def</span> <span class="nf">string_to_component</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwarg</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Allows the creation of a Component object using a string.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s : string</span>
<span class="sd">        One of &#39;W&#39;, &#39;R&#39;, &#39;L&#39;, &#39;J&#39;, &#39;C&#39;, &#39;G&#39;, dicatates the type </span>
<span class="sd">        of component to create</span>
<span class="sd">    args, kwargs : </span>
<span class="sd">        Arguments needed for the component creation</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A component of type ``s``</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;W&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">W</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwarg</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;R&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">R</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwarg</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">L</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwarg</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;J&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">J</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwarg</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">C</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwarg</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;G&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">G</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwarg</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Qcircuit</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class representing a quantum circuit.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        components (dict): Dictionary of components having a label, such that a component </span>
<span class="sd">            with label &#39;L_1&#39; can be obtained by ``Qcircuit.components[&#39;L_1&#39;]``</span>
<span class="sd">        Q_min (float): Modes with have a quality factor below Q_min will not ignored</span>
<span class="sd">        inductors (list): List of inductor objects present in the circuit</span>
<span class="sd">        resistors (list): List of inductor objects present in the circuit</span>
<span class="sd">        junctions (list): List of junction objects present in the circuit</span>
<span class="sd">        capacitors (list): List of capacitor objects present in the circuit</span>
<span class="sd">        netlist (list): List of all components present in the circuit</span>
<span class="sd">        ref_elt (J or L): list of junction or inductor component used as a reference for the calculation </span>
<span class="sd">                        of zero-point fluctations, each index of the list corresponds to a different mode</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netlist</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Q_min</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Modes with have a quality factor below Q_min will not ignored</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">warn_discarded_mode</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># If this is set to True, the user will be notified when a mode is discarded.</span>
        
        <span class="c1"># After an initial estimation of the complex eigenfrequenceis using a diaglinalization</span>
        <span class="c1"># of the companion matrix, the frequencies are polishd to a tolerence</span>
        <span class="c1"># self.root_relative_tolerance using a gradient based root finder, with a maximum number of iterations self.root_max_iterations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_max_iterations</span> <span class="o">=</span> <span class="mf">1e4</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">root_relative_tolerance</span> <span class="o">=</span> <span class="mf">1e-12</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_plotting_normal_mode</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># Used to keep track of which imported plotting_settings to use </span>
                                            <span class="c1"># only set to true when show_normal_mode is called</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotting_parameters_normal_modes</span> <span class="o">=</span> <span class="n">plotting_parameters_normal_modes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotting_parameters_show</span> <span class="o">=</span> <span class="n">plotting_parameters_show</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">netlist</span> <span class="o">=</span> <span class="n">netlist</span> <span class="c1"># List of all components present in the circuit</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_network</span> <span class="o">=</span> <span class="n">_Network</span><span class="p">(</span><span class="n">netlist</span><span class="p">)</span> <span class="c1"># Converts the list of components into a network object</span>
                <span class="c1"># The Network object has methods to compute of the admittance between two nodes</span>
                <span class="c1"># or the tranfer function between two nodes and two others</span>
        
        <span class="c1"># We construct (enpty) lists of all the different type of </span>
        <span class="c1"># components that could be present in the circuit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inductors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">capacitors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">junctions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resistors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wire</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grounds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Initialize a dictionary of components having a label, such that a component </span>
        <span class="c1"># with label &#39;L_1&#39; can be obtained by ``Qcircuit.components[&#39;L_1&#39;]``</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Initialize a list which will contain the labels of the componentns which have</span>
        <span class="c1"># no value (these will have to be specified in most methods as a kwarg)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_no_value_components</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># For each component of the circuit....</span>
        <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">netlist</span><span class="p">:</span>
            <span class="c1"># ...tell the component what circuit it belongs to</span>
            <span class="n">elt</span><span class="o">.</span><span class="n">_circuit</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="c1"># ...and populate the empty lists/dictionaries initialized above with the element if appropriate</span>
            <span class="n">elt</span><span class="o">.</span><span class="n">_set_component_lists</span><span class="p">()</span>


        <span class="c1"># Check that there is at least one inductive element in the circuit</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">junctions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inductors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;There should be at least one junction or inductor in the circuit&quot;</span><span class="p">)</span>

        <span class="c1"># Check that there is at least one capacitive element in the circuit</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">capacitors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;There should be at least one capacitor in the circuit&quot;</span><span class="p">)</span>

                
        <span class="c1"># define the function which returns the inverse of dY</span>
        <span class="c1"># where Y is the admittance at the nodes of an inductive element</span>
        <span class="k">for</span> <span class="n">inductive_element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inductors</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">junctions</span><span class="p">:</span>
            <span class="n">inductive_element</span><span class="o">.</span><span class="n">_compute_flux_zpf_r</span><span class="p">()</span>

        <span class="c1"># Initialize the flux transformation dictionary,</span>
        <span class="c1"># where _flux_transformation_dict[ref_node_minus,ref_node_plus,node_minus,node_plus] </span>
        <span class="c1"># will be populated with a function which gives</span>
        <span class="c1"># the voltage transfer function between the nodes surrounding</span>
        <span class="c1"># the reference element and (node_plus,node_minus)</span>
        <span class="c1"># this function takes as an argument an angular frequency</span>
        <span class="c1"># and keyword arguments if component values need to be specified</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flux_transformation_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># define the functions which returns the components of the characteristic polynomial</span>
        <span class="c1"># (the roots of which are the eigen-frequencies)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_char_poly_coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">lambdify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_no_value_components</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span> 
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_network</span><span class="o">.</span><span class="n">compute_char_poly_coeffs</span><span class="p">(</span><span class="n">is_lossy</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resistors</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">))]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_pp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the plotting parameters used </span>
<span class="sd">            * in the Qcircuit.show method (if self._plotting_normal_mode is False)</span>
<span class="sd">            * in the Qcircuit.show_normal_modes() method (if self._plotting_normal_mode is True)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plotting_normal_mode</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotting_parameters_normal_modes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotting_parameters_show</span>

    <span class="k">def</span> <span class="nf">_parse_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Raises a ValueError </span>
<span class="sd">        * if one of the kwargs is not the label of a circuit element</span>
<span class="sd">        * if a component without a value has not had its value specified in the kwargs </span>

<span class="sd">        Called in all functions accepting keyword arguments (for un-specified circuit components).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs:     </span>
<span class="sd">                    Values for un-specified circuit components, </span>
<span class="sd">                    ex: ``L=1e-9``.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_value_components</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>  <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;A value for the component labelled &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; &quot;</span> 
                        <span class="s2">&quot;has already been specified when building the circuit. &quot;</span>
                        <span class="s2">&quot;To be able to change it, you should re-build the circuit &quot;</span>
                        <span class="s2">&quot;without specifying its value.&quot;</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not the label of a circuit element&#39;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_value_components</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;The value of </span><span class="si">%s</span><span class="s1"> should be specified with the keyword argument </span><span class="si">%s</span><span class="s1">=... &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>

    <span class="nd">@timeit</span>
    <span class="k">def</span> <span class="nf">_set_zeta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sets the Qcircuit.zeta to the circuit eigenfrequencies</span>
<span class="sd">        (including the imaginary part due to losses).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs:     </span>
<span class="sd">                    Values for un-specified circuit components, </span>
<span class="sd">                    ex: ``L=1e-9``.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># Check if the kwargs provided are correct</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_kwargs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs_previous</span><span class="p">:</span>
                <span class="c1"># Avoid doing the same thing two</span>
                <span class="c1"># times in a row</span>
                <span class="k">return</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs_previous</span> <span class="o">=</span> <span class="n">kwargs</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resistors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># Compute the coefficients of the characteristic polynomial.</span>
            <span class="c1"># The roots of this polynomial will provide the complex eigenfrequencies</span>
            <span class="n">char_poly</span> <span class="o">=</span> <span class="n">npPoly</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">coeff</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span> <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_char_poly_coeffs</span><span class="p">])</span>
            
            <span class="c1"># char_poly = remove_multiplicity(char_poly)</span>
        
            <span class="c1"># In this case, the variable of the characteristic polynomial is \omega^2</span>
            <span class="c1"># And we can safely take the real part of the solution as there are no</span>
            <span class="c1"># resistors in the circuit.</span>
            <span class="n">w2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">char_poly</span><span class="o">.</span><span class="n">roots</span><span class="p">())</span>
            <span class="n">w2</span> <span class="o">=</span> <span class="n">polish_roots</span><span class="p">(</span><span class="n">char_poly</span><span class="p">,</span><span class="n">w2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_max_iterations</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_relative_tolerance</span><span class="p">))</span>

            <span class="c1"># Sometimes, when the circuits has vastly different</span>
            <span class="c1"># values for its circuit components or modes are too</span>
            <span class="c1"># decoupled, the symbolic </span>
            <span class="c1"># calculations can yield an incorrect char_poly</span>
            <span class="c1"># We can easily discard some of these casese by throwing away</span>
            <span class="c1"># negative solutions</span>
            <span class="k">for</span> <span class="n">w2_single</span> <span class="ow">in</span> <span class="n">w2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w2_single</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">warn_discarded_mode</span><span class="p">:</span>
                    <span class="n">error_message</span> <span class="o">=</span> <span class="s2">&quot;Imaginary frequency mode f = 1j </span><span class="si">%f</span><span class="s2"> Hz mode found (and discarded).</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">w2_single</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                    <span class="n">warn</span><span class="p">(</span><span class="n">error_message</span><span class="p">)</span>
            <span class="n">w2</span> <span class="o">=</span> <span class="n">w2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">w2</span> <span class="o">&gt;=</span> <span class="mf">0.</span><span class="p">)]</span>

            <span class="c1"># Take the square root to get to the eigenfrequencies</span>
            <span class="n">zeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">w2</span><span class="p">)</span>

            <span class="c1"># Sort solutions with increasing frequency</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">zeta</span><span class="p">))</span>
            <span class="n">zeta</span> <span class="o">=</span> <span class="n">zeta</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># Compute the coefficients of the characteristic polynomial.</span>
            <span class="c1"># The roots of this polynomial will provide the complex eigenfrequencies</span>
            <span class="n">char_poly</span> <span class="o">=</span> <span class="n">npPoly</span><span class="p">([</span><span class="nb">complex</span><span class="p">(</span><span class="n">coeff</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span> <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_char_poly_coeffs</span><span class="p">])</span>
            <span class="c1"># char_poly = remove_multiplicity(char_poly)</span>

            <span class="n">zeta</span> <span class="o">=</span> <span class="n">char_poly</span><span class="o">.</span><span class="n">roots</span><span class="p">()</span>
            <span class="n">zeta</span> <span class="o">=</span> <span class="n">polish_roots</span><span class="p">(</span><span class="n">char_poly</span><span class="p">,</span><span class="n">zeta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_max_iterations</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">root_relative_tolerance</span><span class="p">)</span>

            <span class="c1"># Sort solutions with increasing frequency</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">zeta</span><span class="p">))</span>
            <span class="n">zeta</span> <span class="o">=</span> <span class="n">zeta</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>

            <span class="c1"># Negative modes are discarded</span>
            <span class="n">zeta</span> <span class="o">=</span> <span class="n">zeta</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">zeta</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">0.</span><span class="p">)]</span>

            <span class="c1"># For each solution, its complex conjugate</span>
            <span class="c1"># is also a solution, we want to discard the negative</span>
            <span class="c1"># imaginary part solutions which correspond to unphysical</span>
            <span class="c1"># negative dissipation modes</span>
            <span class="n">zeta</span> <span class="o">=</span> <span class="n">zeta</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">zeta</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">0.</span><span class="p">)]</span>

        <span class="c1"># zero frequency modes are discarded</span>
        <span class="n">zeta</span> <span class="o">=</span> <span class="n">zeta</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">zeta</span><span class="p">),</span><span class="mi">0</span><span class="o">*</span><span class="n">zeta</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_relative_tolerance</span><span class="p">)))]</span>

        <span class="c1"># Only consider modes with Q&gt;self.Q_min (=1 by default)</span>
        <span class="c1"># The reason for this measure is that</span>
        <span class="c1"># 0-frequency solutions (with real parts close to 0)</span>
        <span class="c1"># tend to have frequencies which oscillate between positive and</span>
        <span class="c1"># negative values.</span>
        <span class="c1"># The negative values are discarded which changes the number of modes</span>
        <span class="c1"># and makes parameter sweeps difficult </span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">zeta</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q_min</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">warn_discarded_mode</span><span class="p">:</span>
                <span class="n">error_message</span> <span class="o">=</span> <span class="s2">&quot;Discarding f = </span><span class="si">%f</span><span class="s2"> Hz mode &quot;</span><span class="o">%</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
                <span class="n">error_message</span> <span class="o">+=</span> <span class="s2">&quot;since it has a too low quality factor Q = </span><span class="si">%f</span><span class="s2"> &lt; </span><span class="si">%f</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">w</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">Q_min</span><span class="p">)</span>
                <span class="n">warn</span><span class="p">(</span><span class="n">error_message</span><span class="p">)</span>
        <span class="n">zeta</span> <span class="o">=</span> <span class="n">zeta</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">zeta</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q_min</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">zeta</span><span class="p">))]</span>

        <span class="c1"># Choose reference elements for each mode which </span>
        <span class="c1"># maximize the inverse of dY: we want the reference </span>
        <span class="c1"># element to the element where zero-point fluctuations</span>
        <span class="c1"># in flux are most localized.</span>
        <span class="n">inductive_elements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">junctions</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">inductors</span>
        <span class="n">ref_elt</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">zeta_copy</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">zeta</span><span class="p">)</span>
        <span class="n">zeta</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">zeta_copy</span><span class="p">:</span>
            <span class="n">largest_dYm1</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ref_elt_index</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">ind_index</span><span class="p">,</span><span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inductive_elements</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dYm1</span> <span class="o">=</span> <span class="n">ind</span><span class="o">.</span><span class="n">_flux_zpf_r</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="c1"># Computation of dYm1 failed for some reason</span>
                    <span class="n">dYm1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    
                <span class="k">if</span> <span class="n">dYm1</span><span class="o">&gt;</span><span class="n">largest_dYm1</span><span class="p">:</span>
                    <span class="n">ref_elt_index</span> <span class="o">=</span> <span class="n">ind_index</span>
                    <span class="n">largest_dYm1</span> <span class="o">=</span> <span class="n">dYm1</span>

            <span class="k">if</span> <span class="n">ref_elt_index</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">warn_discarded_mode</span><span class="p">:</span>
                <span class="c1"># Sometimes, when the circuits has vastly different</span>
                <span class="c1"># values for its circuit components or modes are too</span>
                <span class="c1"># decoupled, the symbolic </span>
                <span class="c1"># calculations can yield an incorrect char_poly</span>
                <span class="c1"># We can easily discard some of these cases by throwing away</span>
                <span class="c1"># any solutions with a complex impedance (ImY&#39;&lt;0)</span>
                <span class="n">error_message</span> <span class="o">=</span> <span class="s2">&quot;Discarding f = </span><span class="si">%f</span><span class="s2"> Hz mode.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
                <span class="n">error_message</span> <span class="o">+=</span> <span class="s2">&quot;since the calculation of zero-point-fluctuations was unsuccesful.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">warn</span><span class="p">(</span><span class="n">error_message</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">zeta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="n">ref_elt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inductive_elements</span><span class="p">[</span><span class="n">ref_elt_index</span><span class="p">])</span>
        <span class="n">zeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">zeta</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">zeta</span> <span class="o">=</span> <span class="n">zeta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_elt</span> <span class="o">=</span> <span class="n">ref_elt</span>

    <span class="k">def</span> <span class="nf">_anharmonicities_per_junction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the contribution of each junction to the anharmonicity of each mode.</span>
<span class="sd">        For more details, see the documentation of J.anharmonicity.</span>

<span class="sd">        Anharmonicities are given in units of Hz (not angular frequency).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs:     </span>
<span class="sd">                    Values for un-specified circuit components, </span>
<span class="sd">                    ex: ``L=1e-9``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        anh_per_jun: ndarray</span>
<span class="sd">            where ``anh_per_jun[j,m]`` corresponds to the contribution of junction ``j``</span>
<span class="sd">            to the anharmonicity of mode ``m``</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_zeta</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[[</span><span class="n">j</span><span class="o">.</span><span class="n">anharmonicity</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zeta</span><span class="p">))]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">junctions</span><span class="p">]</span>
    
<div class="viewcode-block" id="Qcircuit.eigenfrequencies">
<a class="viewcode-back" href="../../API/circuit_functions/eigenfrequencies.html#qucat.Qcircuit.eigenfrequencies">[docs]</a>
    <span class="nd">@vectorize_kwargs</span>
    <span class="k">def</span> <span class="nf">eigenfrequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Returns the normal mode frequencies of the circuit.</span>

<span class="sd">        Frequencies are provided in units of Hertz, </span>
<span class="sd">        not in angular frequency.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs:     </span>
<span class="sd">                    Values for un-specified circuit components, </span>
<span class="sd">                    ex: ``L=1e-9``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.array</span>
<span class="sd">            Normal mode frequencies of the circuit, ordered from lowest</span>
<span class="sd">            to highest frequency, given in Hertz.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        These eigen-frequencies :math:`f_m` correspond to the real parts</span>
<span class="sd">        of the complex frequencies which make the conductance matrix</span>
<span class="sd">        singular, or equivalently the real parts of the poles of the impedance</span>
<span class="sd">        calculated between the nodes of an inductor or josephson junction.</span>

<span class="sd">        The Hamiltonian of the circuit is</span>

<span class="sd">        :math:`\hat{H} = \sum_m hf_m\hat{a}_m^\dagger\hat{a}_m + \hat{U}`,</span>

<span class="sd">        where :math:`h` is Plancks constant, </span>
<span class="sd">        :math:`\hat{a}_m` is the annihilation operator of the m-th</span>
<span class="sd">        normal mode of the circuit and :math:`f_m` is the frequency of </span>
<span class="sd">        the m-th normal mode. The frequencies :math:`f_m` would</span>
<span class="sd">        be the resonance frequencies of the circuit if all junctions</span>
<span class="sd">        were replaced with linear inductors. In that case the </span>
<span class="sd">        non-linear part of the Hamiltonian :math:`\hat{U}`, </span>
<span class="sd">        originating in the junction non-linearity, would be 0.</span>

<span class="sd">        For more information on the underlying theory, see https://arxiv.org/pdf/1908.10342.pdf.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_zeta</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zeta</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="o">/</span><span class="n">pi</span></div>

    
<div class="viewcode-block" id="Qcircuit.loss_rates">
<a class="viewcode-back" href="../../API/circuit_functions/loss_rates.html#qucat.Qcircuit.loss_rates">[docs]</a>
    <span class="nd">@vectorize_kwargs</span>
    <span class="k">def</span> <span class="nf">loss_rates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Returns the loss rates of the circuit normal modes.</span>

<span class="sd">        The array is ordered ordered with increasing normal mode frequencies</span>
<span class="sd">        such that the first element of the array corresponds to the loss</span>
<span class="sd">        rate of the lowest frequency mode. Losses are provided in units of Hertz, </span>
<span class="sd">        **not in angular frequency**.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs:     </span>
<span class="sd">                    Values for un-specified circuit components, </span>
<span class="sd">                    ex: ``L=1e-9``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.array</span>
<span class="sd">            Normal mode losses of the circuit</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        These loss rates :math:`\kappa_m` correspond to twice the imaginary parts</span>
<span class="sd">        of the complex frequencies which make the conductance matrix</span>
<span class="sd">        singular, or equivalently twice the imaginary parts of the poles of the impedance</span>
<span class="sd">        calculated between the nodes of an inductor or josephon junction.</span>

<span class="sd">        For further details on the underlying theory, see https://arxiv.org/pdf/1908.10342.pdf.</span>
<span class="sd">        </span>
<span class="sd">        The dynamics of the circuit can be studied in QuTiP</span>
<span class="sd">        by considering collapse operators for the m-th mode </span>
<span class="sd">        :math:`\sqrt{2\pi\kappa_m(n_{th,m}+1)}\hat{a}_m` and </span>
<span class="sd">        :math:`\sqrt{2\pi\kappa_m(n_{th,m})}\hat{a}_m^\dagger`</span>
<span class="sd">        where :math:`n_{th,m}` is the average thermal occupation</span>
<span class="sd">        of mode :math:`m` and :math:`\hat{a}_m` is the annihilation operator of the m-th</span>
<span class="sd">        normal mode of the circuit.</span>
<span class="sd">        Note that dissipation rates that are obtained from this function</span>
<span class="sd">        have to be converted to angular frequencies through the factor :math:`2\pi`.</span>
<span class="sd">        If you are also using a hamiltonian generated from qucat, </span>
<span class="sd">        then it too should be converted to angular frequencies by multiplying </span>
<span class="sd">        the entire Hamiltonian by :math:`2\pi` when performing time-dependant </span>
<span class="sd">        simulations.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_zeta</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zeta</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="o">/</span><span class="n">pi</span></div>

    
<div class="viewcode-block" id="Qcircuit.anharmonicities">
<a class="viewcode-back" href="../../API/circuit_functions/anharmonicities.html#qucat.Qcircuit.anharmonicities">[docs]</a>
    <span class="nd">@vectorize_kwargs</span>
    <span class="k">def</span> <span class="nf">anharmonicities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&#39;&#39;&#39;Returns the anharmonicity of the circuit normal modes.</span>

<span class="sd">        The array is ordered ordered with increasing normal mode frequencies</span>
<span class="sd">        such that the first element of the array corresponds to the </span>
<span class="sd">        anharmonicity of the lowest frequency mode. </span>
<span class="sd">        Anharmonicities are provided in units of Hertz, </span>
<span class="sd">        not in angular frequency.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs:     </span>
<span class="sd">                    Values for un-specified circuit components, </span>
<span class="sd">                    ex: ``L=1e-9``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.array</span>
<span class="sd">            Normal mode anharmonicities</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The Hamiltonian of a circuit in first order perturbation theory is given by</span>

<span class="sd">        :math:`\hat{H} = \sum_m\sum_{n\ne m} (\hbar\omega_m-A_m-\frac{\chi_{mn}}{2})\hat{a}_m^\dagger\hat{a}_m -\frac{A_m}{2}\hat{a}_m^\dagger\hat{a}_m^\dagger\hat{a}_m\hat{a}_m -\chi_{mn}\hat{a}_m^\dagger\hat{a}_m\hat{a}_n^\dagger\hat{a}_n`,</span>

<span class="sd">        valid for weak anharmonicity :math:`\chi_{mn},A_m\ll \omega_m`.</span>

<span class="sd">        Here </span>

<span class="sd">        * :math:`\omega_m` are the frequencies of the normal modes of the circuit where all junctions have been replaced with inductors characterized by their Josephson inductance</span>
<span class="sd">        </span>
<span class="sd">        * :math:`A_m` is the anharmonicity of mode :math:`m` , the difference in frequency of the first two transitions of the mode</span>
<span class="sd">        </span>
<span class="sd">        * :math:`\chi_{mn}` is the shift in mode :math:`m` that incurs if an excitation is created in mode :math:`n`</span>

<span class="sd">        This function returns the values of :math:`A_m`.</span>

<span class="sd">        For more information on the underlying theory, see https://arxiv.org/pdf/1908.10342.pdf.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">Ks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kerr</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Ks</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span></div>

    
<div class="viewcode-block" id="Qcircuit.kerr">
<a class="viewcode-back" href="../../API/circuit_functions/kerr.html#qucat.Qcircuit.kerr">[docs]</a>
    <span class="nd">@vectorize_kwargs</span>
    <span class="k">def</span> <span class="nf">kerr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&#39;&#39;&#39;Returns the Kerr parameters for the circuit normal modes.</span>

<span class="sd">        The diagonal component ``K[m,m]`` of the returned matrix correspond to the</span>
<span class="sd">        anharmonicity (or self-Kerr) of mode ``m``.</span>
<span class="sd">        An off-diagonal component ``K[m,n]`` corresponds to the cross-Kerr coupling</span>
<span class="sd">        between modes ``m`` and ``n``.</span>
<span class="sd">        The modes are indexed with increasing normal mode frequencies, </span>
<span class="sd">        for example ``K[0,1]`` corresponds to the cross-Kerr interaction</span>
<span class="sd">        between the lowest frequency mode and next highest frequency mode.</span>
<span class="sd">        Kerr parameters are provided in units of Hertz, </span>
<span class="sd">        not in angular frequency.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs:     </span>
<span class="sd">                    Values for un-specified circuit components, </span>
<span class="sd">                    ex: ``L=1e-9``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.array of dimension 2</span>
<span class="sd">            Kerr parameters</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The Hamiltonian of a circuit in first order perturbation theory is given by</span>

<span class="sd">        :math:`\hat{H} = \sum_m\sum_{n\ne m} (\hbar\omega_m-A_m-\frac{\chi_{mn}}{2})\hat{a}_m^\dagger\hat{a}_m -\frac{A_m}{2}\hat{a}_m^\dagger\hat{a}_m^\dagger\hat{a}_m\hat{a}_m -\chi_{mn}\hat{a}_m^\dagger\hat{a}_m\hat{a}_n^\dagger\hat{a}_n`,</span>

<span class="sd">        valid for weak anharmonicity :math:`\chi_{mn},A_m\ll \omega_m`.</span>

<span class="sd">        Here </span>

<span class="sd">        * :math:`\omega_m` are the frequencies of the normal modes of the circuit where all junctions have been replaced with inductors characterized by their Josephson inductance</span>
<span class="sd">        </span>
<span class="sd">        * :math:`A_m` is the anharmonicity of mode :math:`m` , the difference in frequency of the first two transitions of the mode</span>
<span class="sd">        </span>
<span class="sd">        * :math:`\chi_{mn}` is the shift in mode :math:`m` that incurs if an excitation is created in mode :math:`n`</span>

<span class="sd">        This function returns the values of :math:`A_m` and :math:`\chi_{mn}` .</span>

<span class="sd">        For more information on the underlying theory, see https://arxiv.org/pdf/1908.10342.pdf.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># Compute anharmonicity per junction ``As``</span>
        <span class="c1"># where ``As[j,m]`` corresponds to the contribution of junction ``j``</span>
        <span class="c1"># to the anharmonicity of mode ``m``</span>
        <span class="n">As</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_anharmonicities_per_junction</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Number of modes in the circuit</span>
        <span class="n">N_modes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zeta</span><span class="p">)</span>

        <span class="c1"># Number of junctions in the circuit</span>
        <span class="n">N_junctions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">junctions</span><span class="p">)</span>

        <span class="c1"># initialize the vector of Kerr coefficients</span>
        <span class="n">Ks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_modes</span><span class="p">,</span> <span class="n">N_modes</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_modes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_modes</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_junctions</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                        <span class="c1"># Add contribution to self-Kerr</span>
                        <span class="n">Ks</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">As</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Add contribution to cross-Kerr</span>
                        <span class="c1"># Note that taking the square root here is fine</span>
                        <span class="c1"># since Ks[i, j]~phi_ki^2*phi_kj^2 is necessarily a positive real</span>
                        <span class="c1"># since phi_ki,phi_kj are real numbers</span>
                        <span class="n">Ks</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">As</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">As</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Ks</span></div>


<div class="viewcode-block" id="Qcircuit.f_k_A_chi">
<a class="viewcode-back" href="../../API/circuit_functions/f_k_A_chi.html#qucat.Qcircuit.f_k_A_chi">[docs]</a>
    <span class="k">def</span> <span class="nf">f_k_A_chi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pretty_print</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&#39;&#39;&#39;Returns the eigenfrequency, loss-rates, anharmonicity, and Kerr parameters of the circuit. </span>

<span class="sd">        Returns these quantities in the form ``[[f_0,f_1,..],[k_0,k_1,..],[A_0,A_1,..],[[A_0,chi_01,..],[chi_10,A_1,..]..]]``</span>

<span class="sd">        Each quantity is returned as a numpy arrays, </span>
<span class="sd">        where each index corresponds to a normal mode, ordered with </span>
<span class="sd">        increasing normal mode frequency.</span>
<span class="sd">        All quantities are provided in units of Hertz, </span>
<span class="sd">        not in angular frequency.</span>

<span class="sd">        This method is equivalent to calling</span>

<span class="sd">        ``[_.eigenfrequencies(**kwargs),_.loss_rates(**kwargs), _.anharmonicities(**kwargs),_.kerr(**kwargs)]``</span>

<span class="sd">        For more details, refer to the functions</span>

<span class="sd">        :meth:`qucat.Qcircuit.eigenfrequencies`</span>

<span class="sd">        :meth:`qucat.Qcircuit.loss_rates`</span>

<span class="sd">        :meth:`qucat.Qcircuit.anharmonicities`</span>

<span class="sd">        :meth:`qucat.Qcircuit.kerr`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pretty_print:   Boolean, optional</span>
<span class="sd">                        If set to True, this method will print a summary</span>
<span class="sd">                        of the system parameters as a table.</span>
<span class="sd">        kwargs:     </span>
<span class="sd">                    Values for un-specified circuit components, </span>
<span class="sd">                    ex: ``L=1e-9``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List of numpy arrays</span>
<span class="sd">            ``[[f_0,f_1,..],[k_0,k_1,..],[A_0,A_1,..],[[A_0,chi_01,..],[chi_10,A_1,..]..]]``</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="c1"># Quantity to be returned: </span>
        <span class="c1"># eigenfrequency, loss-rates, anharmonicity, and Kerr parameters of the circuit</span>
        <span class="n">to_return</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenfrequencies</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>\
            <span class="bp">self</span><span class="o">.</span><span class="n">loss_rates</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>\
            <span class="bp">self</span><span class="o">.</span><span class="n">anharmonicities</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>\
            <span class="bp">self</span><span class="o">.</span><span class="n">kerr</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">pretty_print</span><span class="p">:</span>

            <span class="c1"># Number of modes in the circuit</span>
            <span class="n">N_modes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_return</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Setup a template for the mode/frequency/dissipation/anharmonicity</span>
            <span class="c1"># table row in the form `` 7 spaces | 7 spaces |  7 spaces | 7 spaces |``</span>
            <span class="n">table_line</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">table_line</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">%12s</span><span class="s2"> |&quot;</span>
            <span class="n">table_line</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

            <span class="c1"># Top row for content of columns</span>
            <span class="n">to_print</span> <span class="o">=</span> <span class="n">table_line</span> <span class="o">%</span> <span class="p">(</span>
                <span class="s2">&quot;mode&quot;</span><span class="p">,</span> <span class="s2">&quot; freq. &quot;</span><span class="p">,</span> <span class="s2">&quot; diss. &quot;</span><span class="p">,</span> <span class="s2">&quot; anha. &quot;</span><span class="p">)</span>

            <span class="c1"># add all the other rows (each row is a mode)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">to_return</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">to_print</span> <span class="o">+=</span> <span class="n">table_line</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span><span class="o">+</span><span class="p">[</span><span class="n">pretty_value</span><span class="p">(</span>
                    <span class="n">to_return</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;Hz&#39;</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>

            <span class="n">to_print</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Kerr coefficients (diagonal = Kerr, off-diagonal = cross-Kerr)</span><span class="se">\n</span><span class="s2">&quot;</span>
            
            <span class="c1"># Setup template for the rows of the Kerr coefficients table row</span>
            <span class="c1"># in the form `` 7 spaces | 7 spaces | ...``</span>
            <span class="n">table_line</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_modes</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">table_line</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">%12s</span><span class="s2"> |&quot;</span>
            <span class="n">table_line</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

            <span class="c1"># Top row indexing each column as a mode</span>
            <span class="n">to_print</span> <span class="o">+=</span> <span class="n">table_line</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">([</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">+</span>
                                            <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;   &#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_modes</span><span class="p">)])</span>

            <span class="c1"># Add other rows</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_modes</span><span class="p">):</span>
                <span class="n">line_elements</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_modes</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">line_elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pretty_value</span><span class="p">(</span>
                            <span class="n">to_return</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;Hz&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">line_elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">to_print</span> <span class="o">+=</span> <span class="n">table_line</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">line_elements</span><span class="p">)</span>

            <span class="c1"># Print the two tables</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">to_print</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">to_return</span></div>


<div class="viewcode-block" id="Qcircuit.hamiltonian">
<a class="viewcode-back" href="../../API/circuit_functions/hamiltonian.html#qucat.Qcircuit.hamiltonian">[docs]</a>
    <span class="nd">@refuse_vectorize_kwargs</span><span class="p">(</span><span class="n">exclude</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;modes&#39;</span><span class="p">,</span><span class="s1">&#39;taylor&#39;</span><span class="p">,</span><span class="s1">&#39;excitations&#39;</span><span class="p">,</span><span class="s1">&#39;return_ops&#39;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">modes</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">taylor</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">excitations</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">return_ops</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&#39;&#39;&#39;Returns the circuits Hamiltonian for further analysis with QuTiP.</span>
<span class="sd">        The Hamiltonian is provided in units of frequency (not angular frequency), </span>
<span class="sd">        such that :math:`h=1`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        modes:      array of integers, optional</span>
<span class="sd">                    List of modes to consider, where the modes are </span>
<span class="sd">                    ordered with increasing frequency, such that</span>
<span class="sd">                    ``modes = [0,1]`` would lead to considering only</span>
<span class="sd">                    the two lowest frequency modes of the circuit.</span>
<span class="sd">                    By default all modes are considered.</span>
<span class="sd">        taylor:     integer, optional</span>
<span class="sd">                    Order to which the potential of all josephson</span>
<span class="sd">                    junctions should be taylor-expanded. Default</span>
<span class="sd">                    is `4`.</span>
<span class="sd">        excitations:integer or array of integers, optional  </span>
<span class="sd">                    Number of energy levels considered for each</span>
<span class="sd">                    junction. If one number is given, all modes </span>
<span class="sd">                    have the same number of levels, if an array</span>
<span class="sd">                    is given, its length should match the number</span>
<span class="sd">                    of modes considered. For example if ``modes = [0,1]`` and</span>
<span class="sd">                    ``excitations = [5,10]``, then we will consider</span>
<span class="sd">                    5 excitation levels for mode 0 and 10 for mode 1.</span>
<span class="sd">        return_ops: Boolean, optional</span>
<span class="sd">                    If set to True, a list of the annihilation operators</span>
<span class="sd">                    will be returned along with the hamiltonian in the form</span>
<span class="sd">                    ``&lt;Hamiltonian&gt;, &lt;list of operators&gt;``. </span>
<span class="sd">                    The form of the return is then ``H,[a_0,a_1,..]``</span>
<span class="sd">                    where ``a_i`` is the annihilation operator of the</span>
<span class="sd">                    i-th considered mode, a QuTiP Qobj</span>
<span class="sd">        kwargs:     </span>
<span class="sd">                    Values for un-specified circuit components, </span>
<span class="sd">                    ex: ``L=1e-9``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        qutip.qobj</span>
<span class="sd">            Hamiltonian of the circuit</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        </span>
<span class="sd">        The Hamiltonian of the circuit, with the non-linearity of the Josephson junctions</span>
<span class="sd">        Taylor-expanded, is given in the limit of low dissipation by</span>

<span class="sd">        :math:`\hat{H} = \sum_{m\in\text{modes}} \hbar \omega_m\hat{a}_m^\dagger\hat{a}_m + \sum_j\sum_{2n\le\text{taylor}}E_j\frac{(-1)^{n+1}}{(2n)!}\left[\frac{\phi_{zpf,m,j}}{\phi_0}(\hat{a}_m^\dagger+\hat{a}_m)\right]^{2n}`,</span>
<span class="sd">        </span>
<span class="sd">        where :math:`\hat{a}_m` is the annihilation operator of the m-th</span>
<span class="sd">        normal mode of the circuit, :math:`\omega_m` is the frequency of </span>
<span class="sd">        the m-th normal mode, :math:`E_j` is the Josephson energy of</span>
<span class="sd">        the j-th junction and :math:`\phi_0 = \hbar/2e` and :math:`\phi_{zpf,m,j}` </span>
<span class="sd">        is the zero point fluctuation of mode </span>
<span class="sd">        :math:`m` through junction :math:`j`.</span>

<span class="sd">        In the expression above, ``modes`` and ``taylor`` are arguments of the ``hamiltonian`` function.</span>

<span class="sd">        For more details on the underlying theory, see https://arxiv.org/pdf/1908.10342.pdf</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">qutip</span> <span class="kn">import</span> <span class="n">destroy</span><span class="p">,</span> <span class="n">qeye</span><span class="p">,</span> <span class="n">tensor</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian_modes</span> <span class="o">=</span> <span class="n">modes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian_taylor</span> <span class="o">=</span> <span class="n">taylor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian_excitations</span> <span class="o">=</span> <span class="n">excitations</span>

        <span class="n">fs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenfrequencies</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">modes</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">modes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fs</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="n">error_message</span> <span class="o">=</span><span class="s2">&quot;There are only </span><span class="si">%d</span><span class="s2"> modes in the circuit, and you specified mode index </span><span class="si">%d</span><span class="s2"> &quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="p">),</span><span class="n">m</span><span class="p">)</span>
                <span class="n">error_message</span> <span class="o">+=</span><span class="s2">&quot;corresponding to the </span><span class="si">%d</span><span class="s2">-th mode.&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># error_message +=&quot;\nNote that the numer of modes may change as one sweeps a parameter&quot;</span>
                <span class="c1"># error_message +=&quot; for example if a 0 frequency, spurious mode becomes negative due to &quot;</span>
                <span class="c1"># error_message +=&quot;numerical imprecision. Adding a resistance to the circuit may help with this.&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_message</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">excitations</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
            <span class="n">excitations</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">excitations</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">excitations</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">modes</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;excitations and modes should have the same length&quot;</span><span class="p">)</span>


        <span class="n">H</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">operators</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">junction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">junctions</span><span class="p">]</span>
        <span class="n">qeye_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">qeye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">excitations</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span><span class="n">mode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">modes</span><span class="p">):</span>
            <span class="n">a_to_tensor</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">qeye_list</span><span class="p">)</span>
            <span class="n">a_to_tensor</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">(</span><span class="n">excitations</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">a_to_tensor</span><span class="p">)</span>
            <span class="n">operators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">H</span> <span class="o">+=</span> <span class="n">fs</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span>

            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">junction</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">junctions</span><span class="p">):</span>
                <span class="c1"># Note that zpf returns the flux in units of phi_0 = hbar/2./e</span>
                <span class="n">phi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">junction</span><span class="o">.</span><span class="n">zpf</span><span class="p">(</span><span class="n">quantity</span><span class="o">=</span><span class="s1">&#39;flux&#39;</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span> 
                <span class="c1"># a = x+iy =&gt; -i*(a-a^) = -i(iy+iy) = --1</span>
                <span class="n">phi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">junction</span><span class="o">.</span><span class="n">zpf</span><span class="p">(</span><span class="n">quantity</span><span class="o">=</span><span class="s1">&#39;flux&#39;</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span> 

        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">junction</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">junctions</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">EJ</span> <span class="o">=</span> <span class="p">(</span><span class="n">hbar</span><span class="o">/</span><span class="mf">2.</span><span class="o">/</span><span class="n">e</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">junction</span><span class="o">.</span><span class="n">_get_value</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>
            <span class="k">while</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="n">taylor</span><span class="p">:</span>
                <span class="n">H</span> <span class="o">+=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">EJ</span><span class="o">/</span><span class="n">factorial</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">phi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">return_ops</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">H</span><span class="p">,</span> <span class="n">operators</span>
        <span class="k">return</span> <span class="n">H</span></div>


<div class="viewcode-block" id="Qcircuit.show">
<a class="viewcode-back" href="../../API/circuit_functions/show.html#qucat.Qcircuit.show">[docs]</a>
    <span class="nd">@refuse_vectorize_kwargs</span><span class="p">(</span><span class="n">exclude</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;plot&#39;</span><span class="p">,</span><span class="s1">&#39;return_fig_ax&#39;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
             <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">return_fig_ax</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Plots the circuit.</span>

<span class="sd">        Only works if the circuit was created using the GUI.</span>

<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        plot:           Boolean, optional</span>
<span class="sd">                        If set to True (default), the function will call</span>
<span class="sd">                        plt.show() to display the circuit</span>
<span class="sd">        return_fig_ax:  Boolean, optional</span>
<span class="sd">                        If set to True (default is False), the function will </span>
<span class="sd">                        return figure and axis for further processing using</span>
<span class="sd">                        matplotlib.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Network</span><span class="p">):</span>
            <span class="c1">#TODO recognize if the network is of series/parallel type</span>
            <span class="c1"># in which case the circuit can be constructed anyway</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">            Plotting functions not available if the circuit was not constructed</span>
<span class="s1">            using the GUI.</span>
<span class="s1">            &#39;&#39;&#39;</span><span class="p">)</span>
        

        <span class="n">xs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">line_type</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">netlist</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lt</span> <span class="o">=</span> <span class="n">elt</span><span class="o">.</span><span class="n">_draw</span><span class="p">()</span>
            <span class="n">xs</span> <span class="o">+=</span> <span class="n">x</span>
            <span class="n">ys</span> <span class="o">+=</span> <span class="n">y</span>
            <span class="n">line_type</span> <span class="o">+=</span> <span class="n">lt</span>

        <span class="n">x_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">])</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">])</span>
        <span class="n">y_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ys</span><span class="p">])</span>
        <span class="n">y_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ys</span><span class="p">])</span>

        <span class="n">x_margin</span> <span class="o">=</span> <span class="n">pp</span><span class="p">[</span><span class="s1">&#39;x_fig_margin&#39;</span><span class="p">]</span>
        <span class="c1"># ensures that any text labels are not cutoff</span>
        <span class="n">y_margin</span> <span class="o">=</span> <span class="n">pp</span><span class="p">[</span><span class="s1">&#39;y_fig_margin&#39;</span><span class="p">]</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span>
            <span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">)</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">x_margin</span><span class="p">)</span><span class="o">*</span><span class="n">pp</span><span class="p">[</span><span class="s2">&quot;figsize_scaling&quot;</span><span class="p">],</span>
            <span class="p">((</span><span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">)</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">y_margin</span><span class="p">)</span><span class="o">*</span><span class="n">pp</span><span class="p">[</span><span class="s2">&quot;figsize_scaling&quot;</span><span class="p">]))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">line_type</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;node&quot;</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ys</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">pp</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;node&#39;</span><span class="p">][</span><span class="s1">&#39;diameter&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ys</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">pp</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="n">pp</span><span class="p">[</span><span class="n">line_type</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="s1">&#39;lw&#39;</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">netlist</span><span class="p">:</span>
            <span class="n">elt</span><span class="o">.</span><span class="n">_draw_label</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">x_min</span><span class="o">-</span><span class="n">x_margin</span><span class="p">,</span> <span class="n">x_max</span><span class="o">+</span><span class="n">x_margin</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">y_min</span><span class="o">-</span><span class="n">y_margin</span><span class="p">,</span> <span class="n">y_max</span><span class="o">+</span><span class="n">y_margin</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_fig_ax</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="Qcircuit.show_normal_mode">
<a class="viewcode-back" href="../../API/circuit_functions/show_normal_mode.html#qucat.Qcircuit.show_normal_mode">[docs]</a>
    <span class="nd">@refuse_vectorize_kwargs</span><span class="p">(</span><span class="n">exclude</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;quantity&#39;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">show_normal_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
        <span class="n">mode</span><span class="p">,</span> 
        <span class="n">quantity</span><span class="o">=</span><span class="s1">&#39;current&#39;</span><span class="p">,</span>
        <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">return_fig_ax</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">add_title</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
        <span class="n">add_legend</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&#39;&#39;&#39;Plots a visual representation of a normal mode.</span>

<span class="sd">        Only works if the circuit was created using the GUI.</span>
<span class="sd">        Plots a schematic of the circuit overlayed with </span>
<span class="sd">        arrows representing the complex amplitude of a certain quantity </span>
<span class="sd">        :math:`X` which can be flux, current, charge or voltage.</span>

<span class="sd">        More specifically, the complex amplitude of :math:`X` if a </span>
<span class="sd">        single-photon amplitude coherent state were populating a given mode ``mode``.</span>

<span class="sd">        Current is shown in units of Ampere, voltage in Volts, </span>
<span class="sd">        charge in electron charge, and flux in units of the</span>
<span class="sd">        reduced flux quantum </span>
<span class="sd">        (defined as :math:`\hbar/2e`)</span>

<span class="sd">        The direction of the arrows show what we are defining </span>
<span class="sd">        as positive current for that component.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode:           integer</span>
<span class="sd">                        Determine what mode to plot, where 0 designates</span>
<span class="sd">                        the lowest frequency mode, and the others</span>
<span class="sd">                        are arranged in order of increasing frequency</span>
<span class="sd">        quantity:           string</span>
<span class="sd">                        One of &#39;current&#39; (default), &#39;flux&#39;,&#39;charge&#39;,&#39;voltage&#39;</span>
<span class="sd">                        Determines what quantity the arrows should represent.</span>
<span class="sd">        plot:           Boolean, optional</span>
<span class="sd">                        If set to True (default), the function will call</span>
<span class="sd">                        plt.show() to display the circuit</span>
<span class="sd">        return_fig_ax:  Boolean, optional</span>
<span class="sd">                        If set to True (default is False), the function will </span>
<span class="sd">                        return figure and axis for further processing using</span>
<span class="sd">                        matplotlib.</span>
<span class="sd">        add_title:      Boolean, optional</span>
<span class="sd">                        If set to True (default), the function will </span>
<span class="sd">                        add a title detailing the modes frequency, anharmonicity</span>
<span class="sd">                        and dissipation rate</span>
<span class="sd">        add_legend:     Boolean, optional</span>
<span class="sd">                        If set to True (default), the function will </span>
<span class="sd">                        add a legend detailing the definition of </span>
<span class="sd">                        arrow size and arrow direction</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This annotated quantity, called a phasor, is calculated by multiplying the</span>
<span class="sd">        voltage transfer function :math:`T_{rc}` (between a reference component :math:`r`</span>
<span class="sd">        and the annotated component  :math:`c` ), with</span>
<span class="sd">        :math:`X_{zpf,m,r}`, the zero-point fluctuations of :math:`\hat{X}` at the reference component.</span>
<span class="sd">        </span>
<span class="sd">        Note that resistors make the transfer function :math:`T_{rc}`, and hence the phasors complex.</span>

<span class="sd">        Since this is plotted for a single-photon amplitude coherent state, the absolute value</span>
<span class="sd">        of the annotation is equal to the</span>
<span class="sd">        contribution of a mode to the zero-point fluctuations accross this component.</span>

<span class="sd">        For more detail on the underlying theory, see https://arxiv.org/pdf/1908.10342.pdf.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># This changes the default plotting settings </span>
        <span class="c1"># to those defined in plotting_settings.py</span>
        <span class="c1"># under plotting_parameters_normal_modes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plotting_normal_mode</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># This will set pp to plotting_parameters_normal_modes</span>
        <span class="c1"># (see the definition of the Qcircuit._pp propoerty function)</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span>

        <span class="c1"># Make sure this has been called on a </span>
        <span class="c1"># Qcircuit defined with the GUI</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Network</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">            Plotting functions not available if the circuit was not constructed</span>
<span class="s1">            using the GUI.</span>
<span class="s1">            &#39;&#39;&#39;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">pretty</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">quantity</span><span class="p">):</span>
            <span class="c1"># Utility function to print a pretty </span>
            <span class="c1"># value for the phasor</span>
            <span class="k">if</span> <span class="n">quantity</span> <span class="o">==</span> <span class="s1">&#39;flux&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pretty_value</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">is_complex</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">+</span><span class="sa">u</span><span class="s2">&quot;</span><span class="se">\u03A6</span><span class="s2">_0&quot;</span>
            <span class="k">elif</span> <span class="n">quantity</span> <span class="o">==</span> <span class="s1">&#39;charge&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pretty_value</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">is_complex</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">use_power_10</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;e&#39;</span>
            <span class="k">elif</span> <span class="n">quantity</span> <span class="o">==</span> <span class="s1">&#39;voltage&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pretty_value</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">is_complex</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;V&#39;</span>
            <span class="k">elif</span> <span class="n">quantity</span> <span class="o">==</span> <span class="s1">&#39;current&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pretty_value</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">is_complex</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;A&#39;</span>

        <span class="c1"># Plot the circuit and return the </span>
        <span class="c1"># figure and axis for further </span>
        <span class="c1"># editing below</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">show</span><span class="p">(</span>
            <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">return_fig_ax</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Determine smallest and largest arrow size</span>
        <span class="c1"># Based on the absolute value of the</span>
        <span class="c1"># phasor through all components</span>
        <span class="n">all_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">netlist</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span><span class="n">W</span><span class="p">):</span>
                <span class="n">all_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">zpf</span><span class="p">(</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">,</span> <span class="n">quantity</span> <span class="o">=</span> <span class="n">quantity</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="n">all_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">all_values</span><span class="p">)</span>
        <span class="n">max_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">all_values</span><span class="p">)</span>
        <span class="n">min_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">all_values</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">value_to_01_range</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="c1"># Returns a number between 0 and 1</span>
            <span class="c1"># where 0 corresponds to the smallest</span>
            <span class="c1"># phasor and 1 to the largest</span>

            <span class="k">if</span> <span class="n">pretty</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">max_value</span><span class="p">),</span> <span class="n">quantity</span><span class="p">)</span> <span class="o">==</span> <span class="n">pretty</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">min_value</span><span class="p">),</span> <span class="n">quantity</span><span class="p">):</span>
                <span class="c1"># Case where all the components have</span>
                <span class="c1"># the same phasor magnitude</span>
                <span class="k">return</span> <span class="mf">1.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">-</span><span class="n">min_value</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">max_value</span><span class="o">-</span><span class="n">min_value</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">arrow_width</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">value_01</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># Converts value between 0 and 1</span>
            <span class="c1"># to an arrow width where 0 will</span>
            <span class="c1"># get the ``min_width`` and</span>
            <span class="c1"># 1 will get the ``max_width```</span>

            <span class="k">if</span> <span class="n">value_01</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">value_01</span> <span class="o">=</span> <span class="n">value_to_01_range</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="c1"># part of the plotting parameters</span>
            <span class="c1"># which concern the arrow</span>
            <span class="n">ppnm</span> <span class="o">=</span> <span class="n">pp</span><span class="p">[</span><span class="s1">&#39;normal_mode_arrow&#39;</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">ppnm</span><span class="p">[</span><span class="s1">&#39;min_width&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">value_01</span><span class="o">*</span><span class="p">(</span><span class="n">ppnm</span><span class="p">[</span><span class="s1">&#39;max_width&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">ppnm</span><span class="p">[</span><span class="s1">&#39;min_width&#39;</span><span class="p">]))</span>

        <span class="k">def</span> <span class="nf">arrow_kwargs</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">value_01</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># Constructs the keyword arguments to be passed </span>
            <span class="c1"># in the construction of an arrow based on the </span>
            <span class="c1"># zpf value</span>

            <span class="k">if</span> <span class="n">value_01</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">value_01</span> <span class="o">=</span> <span class="n">value_to_01_range</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="c1"># part of the plotting parameters</span>
            <span class="c1"># which concern the arrow</span>
            <span class="n">ppnm</span> <span class="o">=</span> <span class="n">pp</span><span class="p">[</span><span class="s1">&#39;normal_mode_arrow&#39;</span><span class="p">]</span>

            <span class="c1"># linewidth</span>
            <span class="n">lw</span> <span class="o">=</span> <span class="n">ppnm</span><span class="p">[</span><span class="s1">&#39;min_lw&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">value_01</span><span class="o">*</span><span class="p">(</span><span class="n">ppnm</span><span class="p">[</span><span class="s1">&#39;max_lw&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">ppnm</span><span class="p">[</span><span class="s1">&#39;min_lw&#39;</span><span class="p">])</span>

            <span class="c1"># head size</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">ppnm</span><span class="p">[</span><span class="s1">&#39;min_head&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">value_01</span> <span class="o">*</span> \
                <span class="p">(</span><span class="n">ppnm</span><span class="p">[</span><span class="s1">&#39;max_head&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">ppnm</span><span class="p">[</span><span class="s1">&#39;min_head&#39;</span><span class="p">])</span>

            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;lw&#39;</span><span class="p">:</span> <span class="n">lw</span><span class="p">,</span>
                    <span class="s1">&#39;head_width&#39;</span><span class="p">:</span> <span class="n">head</span><span class="p">,</span>
                    <span class="s1">&#39;head_length&#39;</span><span class="p">:</span> <span class="n">head</span><span class="p">,</span>
                    <span class="s1">&#39;clip_on&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>

        <span class="c1"># For each element in the circuit, if it </span>
        <span class="c1"># isn&#39;t a ground, add an arrow and a label</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">netlist</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span><span class="n">W</span><span class="p">):</span>

                <span class="c1"># phasor for the quantity and for the current</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">zpf</span><span class="p">(</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">,</span> <span class="n">quantity</span> <span class="o">=</span> <span class="n">quantity</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="c1"># location of the element center</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">x_plot_center</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">y_plot_center</span>

                <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">angle</span><span class="o">==</span><span class="n">EAST</span> <span class="ow">or</span> <span class="n">el</span><span class="o">.</span><span class="n">angle</span><span class="o">==</span><span class="n">WEST</span><span class="p">:</span>
                    <span class="c1"># Case of horizontal element</span>

                    <span class="c1"># Text position</span>
                    <span class="n">x_text</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">pp</span><span class="p">[</span><span class="s2">&quot;normal_mode_label&quot;</span><span class="p">][</span><span class="s2">&quot;text_position_horizontal&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">y_text</span> <span class="o">=</span> <span class="n">y</span><span class="o">+</span><span class="n">pp</span><span class="p">[</span><span class="s2">&quot;normal_mode_label&quot;</span><span class="p">][</span><span class="s2">&quot;text_position_horizontal&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

                    <span class="c1"># text alignment</span>
                    <span class="n">ha</span> <span class="o">=</span> <span class="s1">&#39;center&#39;</span>
                    <span class="n">va</span> <span class="o">=</span> <span class="s1">&#39;top&#39;</span>

                    <span class="c1"># Arrow position in y</span>
                    <span class="n">y_arrow</span> <span class="o">=</span> <span class="n">y</span><span class="o">+</span><span class="n">pp</span><span class="p">[</span><span class="s2">&quot;normal_mode_label&quot;</span><span class="p">][</span><span class="s2">&quot;y_arrow&quot;</span><span class="p">]</span>
                    <span class="n">dy_arrow</span> <span class="o">=</span> <span class="mf">0.</span>

                    <span class="c1"># Arrow position in x</span>
                    <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">angle</span> <span class="o">==</span> <span class="n">EAST</span><span class="p">:</span>
                        <span class="c1"># Define the direction for positive values</span>
                        <span class="c1"># and the positive node on the east</span>
                        <span class="n">x_arrow</span> <span class="o">=</span> <span class="n">x</span><span class="o">-</span><span class="n">arrow_width</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
                        <span class="n">dx_arrow</span> <span class="o">=</span> <span class="n">arrow_width</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">el</span><span class="o">.</span><span class="n">angle</span> <span class="o">==</span> <span class="n">WEST</span><span class="p">:</span>
                        <span class="c1"># Define the direction for positive values</span>
                        <span class="c1"># and the positive node on the west</span>
                        <span class="n">x_arrow</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">arrow_width</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
                        <span class="n">dx_arrow</span> <span class="o">=</span> <span class="o">-</span><span class="n">arrow_width</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">angle</span><span class="o">==</span><span class="n">NORTH</span> <span class="ow">or</span> <span class="n">el</span><span class="o">.</span><span class="n">angle</span><span class="o">==</span><span class="n">SOUTH</span><span class="p">:</span>
                    <span class="c1"># Case of vertical element</span>

                    <span class="c1"># Text position</span>
                    <span class="n">x_text</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">pp</span><span class="p">[</span><span class="s2">&quot;normal_mode_label&quot;</span><span class="p">][</span><span class="s2">&quot;text_position_vertical&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">y_text</span> <span class="o">=</span> <span class="n">y</span><span class="o">+</span><span class="n">pp</span><span class="p">[</span><span class="s2">&quot;normal_mode_label&quot;</span><span class="p">][</span><span class="s2">&quot;text_position_vertical&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

                    <span class="c1"># Text alignment</span>
                    <span class="n">ha</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span>
                    <span class="n">va</span> <span class="o">=</span> <span class="s1">&#39;center&#39;</span>

                    <span class="c1"># Arrow x position</span>
                    <span class="n">x_arrow</span> <span class="o">=</span> <span class="n">x</span><span class="o">-</span><span class="n">pp</span><span class="p">[</span><span class="s2">&quot;normal_mode_label&quot;</span><span class="p">][</span><span class="s2">&quot;y_arrow&quot;</span><span class="p">]</span>
                    <span class="n">dx_arrow</span> <span class="o">=</span> <span class="mf">0.</span>
                    
                    
                    <span class="c1"># Arrow position in y</span>
                    <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">angle</span><span class="o">==</span><span class="n">NORTH</span><span class="p">:</span>
                        <span class="c1"># Define the direction for positive values</span>
                        <span class="c1"># and the positive node on the north</span>
                        <span class="n">y_arrow</span> <span class="o">=</span> <span class="n">y</span><span class="o">-</span><span class="n">arrow_width</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
                        <span class="n">dy_arrow</span> <span class="o">=</span> <span class="n">arrow_width</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">el</span><span class="o">.</span><span class="n">angle</span><span class="o">==</span><span class="n">SOUTH</span><span class="p">:</span>
                        <span class="c1"># Define the direction for positive values</span>
                        <span class="c1"># and the positive node on the south</span>
                        <span class="n">y_arrow</span> <span class="o">=</span> <span class="n">y</span><span class="o">+</span><span class="n">arrow_width</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
                        <span class="n">dy_arrow</span> <span class="o">=</span> <span class="o">-</span><span class="n">arrow_width</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>


                <span class="c1"># Add the arrow</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># If the dominating part of the complex number is negative</span>
                    <span class="c1"># Flip the arrow and the value</span>
                    <span class="n">arrow_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_arrow</span><span class="o">+</span><span class="n">dx_arrow</span><span class="p">,</span> <span class="n">y_arrow</span><span class="o">+</span><span class="n">dy_arrow</span><span class="p">,</span> <span class="o">-</span><span class="n">dx_arrow</span><span class="p">,</span> <span class="o">-</span><span class="n">dy_arrow</span><span class="p">]</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">arrow_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_arrow</span><span class="p">,</span> <span class="n">y_arrow</span><span class="p">,</span> <span class="n">dx_arrow</span><span class="p">,</span> <span class="n">dy_arrow</span><span class="p">]</span>
                
                <span class="n">ax</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="o">*</span><span class="n">arrow_coords</span><span class="p">,</span>
                        <span class="n">fc</span><span class="o">=</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;normal_mode_arrow&#39;</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">],</span>
                        <span class="n">ec</span><span class="o">=</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;normal_mode_arrow&#39;</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">],</span>
                        <span class="o">**</span><span class="n">arrow_kwargs</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

                <span class="c1"># Add the annotation</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x_text</span><span class="p">,</span> <span class="n">y_text</span><span class="p">,</span>
                        <span class="n">pretty</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">quantity</span><span class="p">),</span>
                        <span class="n">fontsize</span><span class="o">=</span><span class="n">pp</span><span class="p">[</span><span class="s2">&quot;normal_mode_label&quot;</span><span class="p">][</span><span class="s2">&quot;fontsize&quot;</span><span class="p">],</span>
                        <span class="n">ha</span><span class="o">=</span><span class="n">ha</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="n">va</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span><span class="n">color</span> <span class="o">=</span><span class="n">pp</span><span class="p">[</span><span class="s2">&quot;normal_mode_label&quot;</span><span class="p">][</span><span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="p">)</span>

        <span class="c1"># Add the title</span>
        <span class="k">if</span> <span class="n">add_title</span><span class="p">:</span>
            <span class="n">w</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">chi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_k_A_chi</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Mode </span><span class="si">%d</span><span class="s1">, f=</span><span class="si">%s</span><span class="s1">Hz, k=</span><span class="si">%s</span><span class="s1">Hz, A=</span><span class="si">%s</span><span class="s1">Hz,&#39;</span><span class="o">%</span>
                <span class="p">(</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">pretty_value</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">mode</span><span class="p">]),</span>
                <span class="n">pretty_value</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">mode</span><span class="p">]),</span>
                <span class="n">pretty_value</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">mode</span><span class="p">])),</span>
                <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.97</span><span class="p">),</span>
                <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span>
                <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">,</span>
                <span class="n">xycoords</span><span class="o">=</span><span class="s1">&#39;axes fraction&#39;</span><span class="p">,</span>
                <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> 
                <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>
                
            <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;populated by single-photon amplitude coherent state&#39;</span><span class="p">,</span>
                <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.97</span><span class="o">-</span><span class="mf">0.045</span><span class="p">),</span>
                <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span>
                <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">,</span>
                <span class="n">xycoords</span><span class="o">=</span><span class="s1">&#39;axes fraction&#39;</span><span class="p">,</span>
                <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">add_legend</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">quantity</span> <span class="o">==</span> <span class="s1">&#39;current&#39;</span><span class="p">:</span>
                <span class="n">value_text</span><span class="o">=</span> <span class="s2">&quot;|I|&quot;</span>
            <span class="k">elif</span> <span class="n">quantity</span> <span class="o">==</span> <span class="s1">&#39;voltage&#39;</span><span class="p">:</span>
                <span class="n">value_text</span><span class="o">=</span> <span class="sa">u</span><span class="s2">&quot;|V|&quot;</span>
            <span class="k">if</span> <span class="n">quantity</span> <span class="o">==</span> <span class="s1">&#39;flux&#39;</span><span class="p">:</span>
                <span class="n">value_text</span><span class="o">=</span> <span class="sa">u</span><span class="s2">&quot;|</span><span class="se">\u03A6</span><span class="s2">|&quot;</span>
            <span class="k">elif</span> <span class="n">quantity</span> <span class="o">==</span> <span class="s1">&#39;charge&#39;</span><span class="p">:</span>
                <span class="n">value_text</span><span class="o">=</span> <span class="s2">&quot;|Q|&quot;</span>
            <span class="n">value_text</span> <span class="o">+=</span> <span class="sa">u</span><span class="s2">&quot;exp(i</span><span class="se">\u03B8</span><span class="s2">)&quot;</span>
        
            <span class="n">x_legend</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mf">0.4</span>
            <span class="n">y_legend</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mf">0.25</span>

            <span class="n">legend_text_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;ha&#39;</span><span class="p">:</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                <span class="s1">&#39;va&#39;</span><span class="p">:</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                <span class="s1">&#39;fontsize&#39;</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span> 
                <span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="s1">&#39;normal&#39;</span>
            <span class="p">}</span>
            
            <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x_legend</span><span class="p">,</span> <span class="n">y_legend</span><span class="p">,</span>
                <span class="n">value_text</span><span class="p">,</span>
                <span class="o">**</span><span class="n">legend_text_kwargs</span><span class="p">)</span>

            <span class="n">v01</span> <span class="o">=</span> <span class="mf">0.7</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="n">x_legend</span><span class="o">-</span><span class="n">arrow_width</span><span class="p">(</span><span class="n">value_01</span> <span class="o">=</span> <span class="n">v01</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> 
                    <span class="n">y_legend</span><span class="o">-</span><span class="mf">0.15</span><span class="p">,</span>
                    <span class="n">arrow_width</span><span class="p">(</span><span class="n">value_01</span> <span class="o">=</span> <span class="n">v01</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">fc</span><span class="o">=</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;normal_mode_arrow&#39;</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">],</span>
                    <span class="n">ec</span><span class="o">=</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;normal_mode_arrow&#39;</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">],</span> 
                    <span class="o">**</span><span class="n">arrow_kwargs</span><span class="p">(</span><span class="n">value_01</span> <span class="o">=</span><span class="n">v01</span><span class="p">))</span>
       

        <span class="k">if</span> <span class="n">plot</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plotting_normal_mode</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">return_fig_ax</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="Network">
<a class="viewcode-back" href="../../API/network.html#qucat.Network">[docs]</a>
<span class="k">class</span> <span class="nc">Network</span><span class="p">(</span><span class="n">Qcircuit</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&#39;&#39;&#39;Constructs a Qcircuit object from a list of components without resorting to a graphical user interface.</span>

<span class="sd">    The list can be composed of instances of the :class:`qucat.L`, :class:`qucat.C`, </span>
<span class="sd">    :class:`qucat.R` or :class:`qucat.J` classes</span>
<span class="sd">    for inductors, capacitors, resistors or junctions respectively.</span>

<span class="sd">    This Qcircuit construction method offers the advantage of programmatically constructing</span>
<span class="sd">    the circuit of the GUI class.</span>
<span class="sd">    On could, for example, construct an array of LC-resonators using a python ``for`` loop, which</span>
<span class="sd">    would be tedious using a graphical user interface.</span>
<span class="sd">    The disadvantage is that one cannot use the plotting tools :meth:`show` or </span>
<span class="sd">    :meth:`show_normal_modes` to visualize the circuit or its innerworkings.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    netlist:    list of :class:`qucat.Component`</span>
<span class="sd">                See examples</span>
<span class="sd">                </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    qucat.Qcircuit</span>
<span class="sd">        A Qcircuit object, see qucat.Qcircuit</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Here we construct a parallel combination of a capacitor, inductor and junction, grounded</span>
<span class="sd">    on one end and connected at the other end through a capacitor to a 50 Ohm resistor to ground.</span>

<span class="sd">    .. image:: Network_example_circuit.png</span>

<span class="sd">    Import the Network class, and the components we will need</span>

<span class="sd">    &gt;&gt;&gt; from qucat import Network, R,L,C,J</span>

<span class="sd">    Note that the components (R,L,C,J) accept node indexes as their two first arguments, </span>
<span class="sd">    here we will use the node ``0`` to designate ground. The last arguments should be </span>
<span class="sd">    a label (``str``) or a value (``float``) or both, the order in which these</span>
<span class="sd">    arguments are provided are unimportant.</span>

<span class="sd">    &gt;&gt;&gt; circuit = Network([</span>
<span class="sd">    ... L(0,1,&#39;L&#39;,1e-9), # Add the inductor between ground and node 1</span>
<span class="sd">    ... C(0,1,100e-15,&#39;C&#39;), # Add the capacitor</span>
<span class="sd">    ... J(0,1,&#39;L_J&#39;), # Add the junction</span>
<span class="sd">    ... C(1,2,1e-15), # Add a capacitor which will connect to a resistor</span>
<span class="sd">    ... R(2,0,50) # Add a 50 Ohm resistance to ground</span>
<span class="sd">    ... ])</span>

<span class="sd">    The junction was parametrized only by a string ``L_J`` , </span>
<span class="sd">    this is the best way to proceed if one wants to sweep the value of a </span>
<span class="sd">    component. Indeed, the most computationally expensive part of the </span>
<span class="sd">    analysis is performed upon initializing the Network, subsequently</span>
<span class="sd">    changing the value of a component and re-calculating a quantity </span>
<span class="sd">    such as the frequency or anharmonicity can be performed much faster.</span>

<span class="sd">    For example, we can compute the eigenfrequency, loss-rates, anharmonicity, and Kerr parameters of the circuit</span>
<span class="sd">    for a specific junction inductance.</span>

<span class="sd">    &gt;&gt;&gt; circuit.f_k_A_chi(L_J = 1e-9) </span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netlist</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Network</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">netlist</span><span class="p">)</span></div>


<div class="viewcode-block" id="GUI">
<a class="viewcode-back" href="../../API/gui.html#qucat.GUI">[docs]</a>
<span class="k">class</span> <span class="nc">GUI</span><span class="p">(</span><span class="n">Qcircuit</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&#39;&#39;&#39;Opens a graphical user interface to constructs a circuit.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename:       string</span>
<span class="sd">                    Path to a file which will store all the information</span>
<span class="sd">                    about the graphically constructed circuit.</span>
<span class="sd">    edit:           Boolean</span>
<span class="sd">                    If True (default), the graphical user interface will be opened.</span>
<span class="sd">                    One can set this argument to False to import the circuit without opening</span>
<span class="sd">                    the graphical user interface</span>
<span class="sd">    plot:           Boolean</span>
<span class="sd">                    If True (default), the circuit will be plotted using matplotlib.</span>
<span class="sd">    print_network:  Boolean</span>
<span class="sd">                    If True (default), a text description of the constructed</span>
<span class="sd">                    network will be printed.</span>
<span class="sd">            </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    qucat.Qcircuit</span>
<span class="sd">        A Qcircuit object, see qucat.Qcircuit</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    All the necessary information about the circuit generated by the graphical user interface application</span>
<span class="sd">    is stored in a human-readable format at the specified path.</span>
<span class="sd">    </span>
<span class="sd">    Each line of this text file is in the format:</span>

<span class="sd">    ``type`` ; ``x_minus`` , ``y_minus`` ; ``x_plus`` , ``y_plus`` ; ``value`` ; ``label``</span>

<span class="sd">    and represents a circuit component, wire or ground element.</span>

<span class="sd">    ``type`` can take the values ``L``, ``C``, ``R``, ``J``, ``W`` or ``G`` for </span>
<span class="sd">    inductor, capacitor, resistor, junction, wire or ground respectively.</span>

<span class="sd">    ``value`` will be a float representing the value of the component or will be empty</span>
<span class="sd">    </span>
<span class="sd">    ``label`` will be a string corresponding to the label of the component or will be empty</span>

<span class="sd">    ``x/y_minus`` (``x/y_plus``) represents the horizontal/vertical location of the minus (plus) node of the component.</span>
<span class="sd">    Negative value are allowed and components have a length of 1 unit.</span>
<span class="sd">    </span>
<span class="sd">    For example, the circuit below, is described by the following text file</span>

<span class="sd">    ::</span>

<span class="sd">        L;3,-10;3,-11;1.000000e-09;L</span>
<span class="sd">        C;4,-10;4,-11;1.000000e-13;C</span>
<span class="sd">        J;5,-10;5,-11;;L_J</span>
<span class="sd">        C;5,-12;6,-12;1.000000e-15;</span>
<span class="sd">        R;7,-11;7,-12;5.000000e+01;</span>
<span class="sd">        G;7,-10;7,-11;;</span>


<span class="sd">    .. image:: Network_example_circuit.png</span>
<span class="sd">    </span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">edit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">print_network</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">_unittesting</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="c1"># Note: this will also give a valid path if filename was specified using </span>
        <span class="c1"># an absolute path</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span><span class="n">filename</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
            <span class="c1"># if file does not exist force the gui to open</span>
            <span class="n">edit</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># and create the folder </span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># ... and file</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="n">edit</span><span class="p">:</span>
            <span class="n">run</span><span class="p">([</span><span class="n">sys</span><span class="o">.</span><span class="n">executable</span><span class="p">,</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span><span class="s2">&quot;_gui.py&quot;</span><span class="p">),</span>
                <span class="n">filename</span><span class="p">])</span>

        <span class="n">netlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">el</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">el</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">el</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">el</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">el</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">el</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                <span class="n">netlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">string_to_component</span><span class="p">(</span><span class="n">el</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">el</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">el</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">v</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">GUI</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">netlist</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">netlist</span><span class="p">:</span>
            <span class="n">el</span><span class="o">.</span><span class="n">_set_plot_coordinates</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">print_network</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="p">[</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">netlist</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span><span class="n">W</span><span class="p">)]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span>
                    <span class="n">el</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="nb">min</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">node_minus</span><span class="p">,</span><span class="n">el</span><span class="o">.</span><span class="n">node_plus</span><span class="p">),</span>
                    <span class="nb">max</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">node_minus</span><span class="p">,</span><span class="n">el</span><span class="o">.</span><span class="n">node_plus</span><span class="p">),</span>
                    <span class="n">el</span><span class="o">.</span><span class="n">_to_string</span><span class="p">(</span><span class="n">use_unicode</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">_Network</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The _Network class parses network arrays generated by the GUI</span>
<span class="sd">    or written manually by the user. </span>
<span class="sd">    It allows the computation of the R, L and C matrices, the</span>
<span class="sd">    admittance Y of the network between</span>
<span class="sd">    two nodes as well as the voltage transfer function of the network</span>
<span class="sd">    between two ports (4 nodes).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    netlist : list</span>
<span class="sd">        list of Component objects</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@timeit</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netlist</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">netlist</span> <span class="o">=</span> <span class="n">netlist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parse_netlist</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There are no components in the circuit&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_connected</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There are two sub-circuits which are not connected&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shorts</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Your circuit appears to be open or shorted making the analysis impossible&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_opens</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Your circuit appears to be open or shorted making the analysis impossible&quot;</span><span class="p">)</span>

    <span class="nd">@timeit</span>
    <span class="k">def</span> <span class="nf">is_connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
        <span class="n">nodes_encountered</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
        <span class="n">start_node</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Determines if a nework is connected (graph theory term).</span>
<span class="sd">        </span>
<span class="sd">        Starting at &quot;start_node&quot;, </span>
<span class="sd">        the algorithm will go from neighbouring node</span>
<span class="sd">        to neighbouring node, adding all encountered</span>
<span class="sd">        nodes to the encountered_nodes list. </span>
<span class="sd">        </span>
<span class="sd">        At then end we check if</span>
<span class="sd">        all the nodes of the network were encountered</span>
<span class="sd">        by checking the length of this list with respect</span>
<span class="sd">        to the total number of nodes</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">encountered_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">start_node</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Starting point of the algo</span>
        

        <span class="k">def</span> <span class="nf">add_neighboors_to_encountered_nodes</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">encountered_nodes</span><span class="p">:</span>
                <span class="n">encountered_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">neighboor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                    <span class="n">add_neighboors_to_encountered_nodes</span><span class="p">(</span><span class="n">neighboor</span><span class="p">)</span>

        <span class="n">add_neighboors_to_encountered_nodes</span><span class="p">(</span><span class="n">start_node</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">encountered_nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">has_shorts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Determines if there is an short circuit. </span>

<span class="sd">        For each node, we construct the network where</span>
<span class="sd">        that node has been removed. </span>

<span class="sd">        If the removal of that node leads to two distinct, </span>
<span class="sd">        non-connected circuits, then that node was a point </span>
<span class="sd">        at which the circuit was being shorted.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">node_to_remove</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span><span class="p">)):</span>
            <span class="c1"># create a copy of the network</span>
            <span class="n">partial_network</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

            <span class="c1"># remove the node_to_remove from the network</span>
            <span class="k">for</span> <span class="n">other_node</span> <span class="ow">in</span> <span class="n">partial_network</span><span class="o">.</span><span class="n">net_dict</span><span class="p">[</span><span class="n">node_to_remove</span><span class="p">]:</span>
                <span class="k">del</span> <span class="n">partial_network</span><span class="o">.</span><span class="n">net_dict</span><span class="p">[</span><span class="n">other_node</span><span class="p">][</span><span class="n">node_to_remove</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">partial_network</span><span class="o">.</span><span class="n">net_dict</span><span class="p">[</span><span class="n">node_to_remove</span><span class="p">]</span>
            
            <span class="c1"># check if that network is connected</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">partial_network</span><span class="o">.</span><span class="n">is_connected</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># No shorts were found</span>
        <span class="k">return</span> <span class="kc">False</span>
        
    <span class="k">def</span> <span class="nf">has_opens</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Determines if there is an open connection in the </span>
<span class="sd">        circuit. </span>

<span class="sd">        If there are only two nodes in the circuit, it cannot be open. </span>
<span class="sd">        This is because through another check we are imposing that the circuit has at least</span>
<span class="sd">        two types of components, one inductive, one capacitive.</span>
<span class="sd">        So a two node circuit will at minimum be an LC or JC circuit.</span>

<span class="sd">        If there are more than two nodes, and one of the nodes is connected </span>
<span class="sd">        to only one other, the circuit is open.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">connections</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">connections</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">parse_netlist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">merge_chains</span><span class="p">(</span><span class="n">chains</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;Merges two chains (two arrays)&#39;&#39;&#39;</span>
            <span class="n">to_add</span> <span class="o">=</span> <span class="n">chains</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">chains</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">chains</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">chains</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">to_add</span>
            <span class="k">return</span> <span class="n">chains</span>

        <span class="c1"># ``chains``` is a list of node-lists (node-list = a chain)</span>
        <span class="c1"># each chain lists nodes which are connected one to another</span>
        <span class="c1"># either through wires or through ground</span>
        <span class="n">chains</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># We start by grouping all nodes which are connected by wires </span>
        <span class="c1"># into chains of nodes indexed by a integer which is to become </span>
        <span class="c1"># the new node names  for future calculations</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">netlist</span><span class="p">:</span>

            <span class="c1"># Go through all the wires (note: grounds are instances of wires)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span><span class="n">W</span><span class="p">):</span>
                
                <span class="c1"># If this element is a ground, call it&#39;s negative node &#39;__ground&#39;</span>
                <span class="n">np</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">node_plus</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="ow">is</span> <span class="n">G</span><span class="p">:</span>
                    <span class="n">nm</span> <span class="o">=</span> <span class="s1">&#39;__ground&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nm</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">node_minus</span>

                <span class="c1"># added tells us if both nodes have already </span>
                <span class="c1"># been added to a same chain</span>
                <span class="n">added</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="c1"># go through all chains to see if it</span>
                <span class="c1"># contains the nodes of this wire</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chains</span><span class="p">):</span>

                    <span class="c1"># If both node of the wire have already been </span>
                    <span class="c1"># added to a same chain, don&#39;t do anyting</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">nm</span> <span class="ow">in</span> <span class="n">ch</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">np</span> <span class="ow">in</span> <span class="n">ch</span><span class="p">):</span>
                        <span class="n">added</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># If minus node was added to chain &#39;ch&#39;...</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="n">nm</span> <span class="ow">in</span> <span class="n">ch</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">ch2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chains</span><span class="p">):</span>
                            <span class="c1"># ...and plus node to chain &#39;ch2&#39;</span>
                            <span class="k">if</span> <span class="n">np</span> <span class="ow">in</span> <span class="n">ch2</span><span class="p">:</span>
                                <span class="c1"># merge the two chains</span>
                                <span class="n">chains</span> <span class="o">=</span> <span class="n">merge_chains</span><span class="p">(</span><span class="n">chains</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                                <span class="n">added</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">if</span> <span class="n">added</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                            <span class="c1"># otherwise add plus node to chain &#39;ch&#39;</span>
                            <span class="n">ch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="p">)</span>
                            <span class="n">added</span> <span class="o">=</span> <span class="kc">True</span>
                    
                    <span class="c1"># same check for the plus node</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="n">np</span> <span class="ow">in</span> <span class="n">ch</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">ch2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chains</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">nm</span> <span class="ow">in</span> <span class="n">ch2</span><span class="p">:</span>
                                <span class="n">chains</span> <span class="o">=</span> <span class="n">merge_chains</span><span class="p">(</span><span class="n">chains</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                                <span class="n">added</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">if</span> <span class="n">added</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                            <span class="n">ch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nm</span><span class="p">)</span>
                            <span class="n">added</span> <span class="o">=</span> <span class="kc">True</span>
                
                <span class="c1"># if none of the nodes were present in chains, </span>
                <span class="c1"># create a new chain linking the two nodes of the wire</span>
                <span class="k">if</span> <span class="n">added</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">chains</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">nm</span><span class="p">,</span> <span class="n">np</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">plot_node_to_new_node</span><span class="p">(</span><span class="n">plot_node</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Transforms the node ``plot_node``` to a new node.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            plot_node:  typically a string or an integer, but could be any</span>
<span class="sd">                        hashable object</span>
<span class="sd">                        For GUI generated networks, </span>
<span class="sd">                        this is a string &#39;x,y&#39; that determines the position</span>
<span class="sd">                        of the node when plotting it.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            i:          integer, a unique number corresponding to all nodes</span>
<span class="sd">                        connected via a wire or ground.</span>
<span class="sd">                        ``i`` is one of [0,..,N-1] where N is the number of </span>
<span class="sd">                        nodes in the circuit stripped of all wires.</span>
<span class="sd">        </span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># if plot_node is already in a chain, </span>
            <span class="c1"># return the index of that chain in ``chains``</span>
            <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">chains</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">plot_node</span> <span class="ow">in</span> <span class="n">ch</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">i</span>
                <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>

            <span class="c1"># other wise append ``chains`` and </span>
            <span class="c1"># return the the last index of ``chains``</span>
            <span class="n">chains</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">plot_node</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">i</span>

        <span class="c1"># replace plotting nodes with new nodes</span>
        <span class="c1"># for all non-wire elements</span>
        <span class="c1"># and make a list of all nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">netlist</span><span class="p">:</span>
            <span class="n">el</span><span class="o">.</span><span class="n">_node_minus_plot</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">node_minus</span>
            <span class="n">el</span><span class="o">.</span><span class="n">_node_plus_plot</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">node_plus</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span><span class="n">W</span><span class="p">):</span>
                <span class="n">el</span><span class="o">.</span><span class="n">node_minus</span> <span class="o">=</span> <span class="n">plot_node_to_new_node</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">node_minus</span><span class="p">)</span>
                <span class="n">el</span><span class="o">.</span><span class="n">node_plus</span> <span class="o">=</span> <span class="n">plot_node_to_new_node</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">node_plus</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">node_minus</span> <span class="o">==</span> <span class="n">el</span><span class="o">.</span><span class="n">node_plus</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Your circuit appears to be shorted, making the analysis impossible&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_minus</span><span class="p">,</span> <span class="n">el</span><span class="o">.</span><span class="n">node_plus</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        
        <span class="c1"># build ``net_dict``, a dictionary such that  </span>
        <span class="c1"># ``net_dict[node_A][node_B]`` gives the non-wire circuit </span>
        <span class="c1"># component connecting ``node_A`` and ``node_B``.</span>
        <span class="c1"># If ``node_A`` and ``node_B`` are not connected, </span>
        <span class="c1"># calling ``net_dict[node_A][node_B]`` will raise a KeyError</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">netlist</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span><span class="n">W</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">el</span><span class="o">.</span><span class="n">node_minus</span><span class="p">,</span> <span class="n">el</span><span class="o">.</span><span class="n">node_plus</span><span class="p">)</span>

    <span class="nd">@timeit</span>
    <span class="k">def</span> <span class="nf">compute_char_poly_coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_lossy</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        
        <span class="nd">@timeit</span>
        <span class="k">def</span> <span class="nf">determinant</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">matrix</span><span class="o">.</span><span class="n">berkowitz_det</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">is_lossy</span> <span class="o">=</span> <span class="n">is_lossy</span>
        <span class="n">ntr</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="c1"># ntr stands for Network To Reduce</span>

        <span class="c1"># compute conductance matrix</span>
        <span class="n">ntr</span><span class="o">.</span><span class="n">compute_RLC_matrices</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_lossy</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="n">char_poly</span> <span class="o">=</span> <span class="n">determinant</span><span class="p">((</span><span class="n">ntr</span><span class="o">.</span><span class="n">RLC_matrices</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">ntr</span><span class="o">.</span><span class="n">RLC_matrices</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">ntr</span><span class="o">.</span><span class="n">RLC_matrices</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]))</span>
            <span class="n">char_poly</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">char_poly</span><span class="p">),</span> <span class="n">w</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">char_poly_order</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">polys</span><span class="o">.</span><span class="n">polytools</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span>
                <span class="n">char_poly</span><span class="p">,</span> <span class="n">gen</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>  <span class="c1"># Order of the polynomial</span>
            <span class="c1"># Get polynomial coefficients, index 0 = lowest order term</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">char_poly_coeffs_analytical</span> <span class="o">=</span>\
                <span class="p">[</span><span class="n">char_poly</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">char_poly_order</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w2</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;w2&#39;</span><span class="p">)</span>
            <span class="n">char_poly</span> <span class="o">=</span> <span class="n">determinant</span><span class="p">((</span><span class="o">-</span><span class="n">ntr</span><span class="o">.</span><span class="n">RLC_matrices</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">w2</span><span class="o">*</span><span class="n">ntr</span><span class="o">.</span><span class="n">RLC_matrices</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]))</span>
            <span class="n">char_poly</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">char_poly</span><span class="p">),</span> <span class="n">w2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">char_poly_order</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">polys</span><span class="o">.</span><span class="n">polytools</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">char_poly</span><span class="p">,</span> <span class="n">gen</span><span class="o">=</span><span class="n">w2</span><span class="p">)</span>  <span class="c1"># Order of the polynomial</span>
            <span class="c1"># Get polynomial coefficients, index 0 = lowest order term</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">char_poly_coeffs_analytical</span> <span class="o">=</span>\
                <span class="p">[</span><span class="n">char_poly</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">w2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">char_poly_order</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>  
                
        
        <span class="c1"># Divide by w if possible</span>
        <span class="n">n</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_poly_coeffs_analytical</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">n</span><span class="o">+=</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">char_poly_coeffs_analytical</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_poly_coeffs_analytical</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">char_poly_coeffs_analytical</span>

    <span class="k">def</span> <span class="nf">compute_RLC_matrices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">N_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RLC_matrices</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;R&#39;</span><span class="p">:</span><span class="n">sp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_nodes</span><span class="p">),</span>
            <span class="s1">&#39;L&#39;</span><span class="p">:</span><span class="n">sp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_nodes</span><span class="p">),</span>
            <span class="s1">&#39;C&#39;</span><span class="p">:</span><span class="n">sp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_nodes</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_nodes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">j</span><span class="o">&gt;</span><span class="n">i</span><span class="p">:</span>
                    <span class="n">RLC_matrix_components</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">_get_RLC_matrix_components</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RLC_matrices</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">RLC_matrices</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">RLC_matrix_components</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">RLC_matrices</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">RLC_matrix_components</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">RLC_matrices</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">RLC_matrix_components</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">RLC_matrices</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">RLC_matrix_components</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="c1"># count the number of coefficients in each row</span>
        <span class="n">number_coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_nodes</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RLC_matrices</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_nodes</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_nodes</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RLC_matrices</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">number_coefficients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>


        <span class="c1"># set a ground </span>
        <span class="n">ground_node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">number_coefficients</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RLC_matrices</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RLC_matrices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">row_del</span><span class="p">(</span><span class="n">ground_node</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RLC_matrices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">col_del</span><span class="p">(</span><span class="n">ground_node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">node_minus</span><span class="p">,</span> <span class="n">node_plus</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Modifies the ``net_dict`` variable such that ``node_minus``</span>
<span class="sd">        and ``node_plus`` are marked as connected in future calculations.</span>
<span class="sd">        ``net_dict`` is a dictionary such that  </span>
<span class="sd">        ``net_dict[node_A][node_B]`` gives the non-wire circuit </span>
<span class="sd">        component connecting ``node_A`` and ``node_B``.</span>
<span class="sd">        If ``node_A`` and ``node_B`` are not connected, </span>
<span class="sd">        calling ``net_dict[node_A][node_B]`` will raise a KeyError</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        element:    a ``Circuit`` object which is not a Wire or a Ground</span>
<span class="sd">        node_minus: integer</span>
<span class="sd">                    negative node of the element</span>
<span class="sd">        node_plus: integer</span>
<span class="sd">                    positive node of the element        </span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># Connect node minus to node plus</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># If the nodes are already connected, add this element in parallel </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span><span class="p">[</span><span class="n">node_minus</span><span class="p">][</span><span class="n">node_plus</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span><span class="p">[</span><span class="n">node_minus</span><span class="p">][</span><span class="n">node_plus</span><span class="p">]</span> <span class="o">|</span> <span class="n">element</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># Case where the nodes are not connected</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span><span class="p">[</span><span class="n">node_minus</span><span class="p">][</span><span class="n">node_plus</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span>

        <span class="c1"># Connect node plus to node minus</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span><span class="p">[</span><span class="n">node_plus</span><span class="p">][</span><span class="n">node_minus</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span><span class="p">[</span><span class="n">node_plus</span><span class="p">][</span><span class="n">node_minus</span><span class="p">]</span> <span class="o">|</span> <span class="n">element</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span><span class="p">[</span><span class="n">node_plus</span><span class="p">][</span><span class="n">node_minus</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span>

    <span class="k">def</span> <span class="nf">remove_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_to_remove</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Makes use of the star-mesh transform to remove the ``node_to_remove`` from the network.</span>
<span class="sd">        A node N=``node_to_remove`` connected to nodes A,B,C,.. through impedances </span>
<span class="sd">        Z_A,Z_B,... (the star) can be eliminated </span>
<span class="sd">        if we interconnect nodes A,B,C,.. with impedances Z_{AB},Z_{AC},Z_{BC},...</span>
<span class="sd">        given by Z_{XY} = Z_XZ_Y\sum_M1/Z_M. </span>
<span class="sd">        The resulting network is called the mesh.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node: integer, node to be removed of the network stored in ``net_dict`` </span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># List of (connecting_nodes, connecting_components) connecting the </span>
        <span class="c1"># node_to_remove to (nearest neighbour) connecting_nodes</span>
        <span class="n">connections</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span><span class="p">[</span><span class="n">node_to_remove</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>

        <span class="c1"># Sum of admittances of connecting_components</span>
        <span class="n">sum_Y</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">elt</span><span class="o">.</span><span class="n">_admittance</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">connections</span><span class="p">])</span>

        <span class="c1"># Go through all pairs of connecting nodes</span>
        <span class="c1"># and calculate the admittance Y_XY that will connect them </span>
        <span class="c1"># in the mesh</span>
        <span class="n">mesh_to_add</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">node_A</span><span class="p">,</span> <span class="n">elt_A</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">connections</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">node_B</span><span class="p">,</span> <span class="n">elt_B</span> <span class="ow">in</span> <span class="n">connections</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">Y</span> <span class="o">=</span> <span class="n">elt_A</span><span class="o">.</span><span class="n">_admittance</span><span class="p">()</span><span class="o">*</span><span class="n">elt_B</span><span class="o">.</span><span class="n">_admittance</span><span class="p">()</span><span class="o">/</span><span class="n">sum_Y</span>
                <span class="n">mesh_to_add</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">Admittance</span><span class="p">(</span><span class="n">node_A</span><span class="p">,</span> <span class="n">node_B</span><span class="p">,</span> <span class="n">Y</span><span class="p">),</span> <span class="n">node_A</span><span class="p">,</span> <span class="n">node_B</span><span class="p">])</span>

        <span class="c1"># Remove the node_to_remove from the net_dict, along with all</span>
        <span class="c1"># the connecting components</span>
        <span class="k">for</span> <span class="n">other_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span><span class="p">[</span><span class="n">node_to_remove</span><span class="p">]:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span><span class="p">[</span><span class="n">other_node</span><span class="p">][</span><span class="n">node_to_remove</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span><span class="p">[</span><span class="n">node_to_remove</span><span class="p">]</span>

        <span class="c1"># Add admittances Y_XY connecting nodes X,Y directly adjascent to </span>
        <span class="c1"># the removed node</span>
        <span class="k">for</span> <span class="n">mesh_branch</span> <span class="ow">in</span> <span class="n">mesh_to_add</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="o">*</span><span class="n">mesh_branch</span><span class="p">)</span>

    <span class="nd">@timeit</span>
    <span class="k">def</span> <span class="nf">admittance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_minus</span><span class="p">,</span> <span class="n">node_plus</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Compute the admittance of the network between two nodes </span>
<span class="sd">        ``node_plus`` and ``node_minus`` </span>
<span class="sd">        by removing all other nodes through star-mesh transformations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_minus: integer </span>
<span class="sd">        node_plus: integer</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">node_minus</span> <span class="o">==</span> <span class="n">node_plus</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;node_minus == node_plus&#39;</span><span class="p">)</span>

        <span class="c1"># Create a temporary copy of the network which will be reduced</span>
        <span class="n">ntr</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="c1"># ntr stands for Network To Reduce</span>

        <span class="c1"># # order nodes from the node with the least amount of connections</span>
        <span class="c1"># # to the one with the most</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">ntr</span><span class="o">.</span><span class="n">net_dict</span><span class="p">]</span>
        <span class="n">nodes_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">ntr</span><span class="o">.</span><span class="n">net_dict</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">])</span>
        <span class="n">nodes_sorted</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodes_order</span><span class="p">]</span>
        
        <span class="c1"># Remove all nodes except from node_minus, node_plus</span>
        <span class="c1"># through star-mesh transforms with the remove_node function</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes_sorted</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">node_minus</span><span class="p">,</span> <span class="n">node_plus</span><span class="p">]:</span>
                <span class="n">ntr</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># Compute the admittance between the two remaining nodes: </span>
        <span class="c1"># node_minus and node_plus</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">ntr</span><span class="o">.</span><span class="n">net_dict</span><span class="p">[</span><span class="n">node_minus</span><span class="p">][</span><span class="n">node_plus</span><span class="p">]</span><span class="o">.</span><span class="n">_admittance</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Y</span>

    <span class="k">def</span> <span class="nf">branch_admittance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_1</span><span class="p">,</span> <span class="n">node_2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the admittance in the branch connecting ``node_1`` and ``node_2``.</span>
<span class="sd">        If they are not directly connected through a single Component, this function</span>
<span class="sd">        returns 0 (i.e. the admittnce of an open circuit).</span>
<span class="sd">        This function is written to avoid calling try/except clauses repetitivly</span>
<span class="sd">        to verify if ``self.net_dict[node_1][node_2]`` is an existing key</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_1: integer </span>
<span class="sd">        node_2: integer</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">node_1</span> <span class="o">==</span> <span class="n">node_2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;node_1 == node_2&#39;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_dict</span><span class="p">[</span><span class="n">node_1</span><span class="p">][</span><span class="n">node_2</span><span class="p">]</span><span class="o">.</span><span class="n">_admittance</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.</span>

    <span class="k">def</span> <span class="nf">transfer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_left_minus</span><span class="p">,</span> <span class="n">node_left_plus</span><span class="p">,</span> <span class="n">node_right_minus</span><span class="p">,</span> <span class="n">node_right_plus</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the transfer function V_right/V_left relating the voltage on </span>
<span class="sd">        a port &#39;right&#39; defined by ``node_right_minus`` and ``node_right_plus``</span>
<span class="sd">        and a port &#39;left&#39; defined by ``node_left_minus`` and ``node_left_plus``</span>
<span class="sd">        We proceed by constructing an ABCD matrix and returning V_right/V_left = 1/A</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_left_minus: integer </span>
<span class="sd">        node_left_plus: integer</span>
<span class="sd">        node_right_minus: integer</span>
<span class="sd">        node_right_plus: integer</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">node_left_minus</span> <span class="o">==</span> <span class="n">node_left_plus</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;node_left_minus == node_left_plus&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">node_right_minus</span> <span class="o">==</span> <span class="n">node_right_plus</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;node_right_minus == node_right_plus&#39;</span><span class="p">)</span>

        <span class="c1"># Case where the left an right port are identical</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node_left_minus</span> <span class="o">==</span> <span class="n">node_right_minus</span><span class="p">)</span>\
            <span class="ow">and</span> <span class="p">(</span><span class="n">node_left_plus</span> <span class="o">==</span> <span class="n">node_right_plus</span><span class="p">):</span>
            <span class="k">return</span> <span class="mf">1.</span>

        <span class="c1"># Case where the left an right port are identical, but inverted</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">node_left_plus</span> <span class="o">==</span> <span class="n">node_right_minus</span><span class="p">)</span>\
            <span class="ow">and</span> <span class="p">(</span><span class="n">node_left_minus</span> <span class="o">==</span> <span class="n">node_right_plus</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="mf">1.</span>

        <span class="c1"># If the ports are not identical, reduce the network such that only</span>
        <span class="c1"># the nodes provided as arguments remain</span>

        <span class="c1"># Create a temporary copy of the network which will be reduced        </span>
        <span class="n">ntr</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="c1"># ntr stands for Network To Reduce</span>
        
        <span class="c1"># # order nodes from the node with the least amount of connections</span>
        <span class="c1"># # to the one with the most</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">ntr</span><span class="o">.</span><span class="n">net_dict</span><span class="p">]</span>
        <span class="n">nodes_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">ntr</span><span class="o">.</span><span class="n">net_dict</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">])</span>
        <span class="n">nodes_sorted</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodes_order</span><span class="p">]</span>

        <span class="c1"># Remove nodes using the star-mesh relation</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes_sorted</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">node_left_minus</span><span class="p">,</span> <span class="n">node_left_plus</span><span class="p">,</span> <span class="n">node_right_minus</span><span class="p">,</span> <span class="n">node_right_plus</span><span class="p">]:</span>
                <span class="n">ntr</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">node_left_minus</span> <span class="ow">in</span> <span class="p">[</span><span class="n">node_right_plus</span><span class="p">,</span> <span class="n">node_right_minus</span><span class="p">])</span> <span class="ow">or</span>\
            <span class="p">(</span><span class="n">node_left_plus</span> <span class="ow">in</span> <span class="p">[</span><span class="n">node_right_plus</span><span class="p">,</span> <span class="n">node_right_minus</span><span class="p">]):</span>

        <span class="c1"># Case where there are two of the nodes provided as arguments </span>
        <span class="c1"># are identical. </span>
        <span class="c1"># The circuit has then three distinct nodes connected by</span>
        <span class="c1"># three components.</span>
        <span class="c1"># For this case, the ABCD matrix can be constructed following </span>
        <span class="c1"># the before last case of Table 4.1 in Microwave Engineering (Pozar)</span>
        <span class="c1"># Indeed, all these cases are equivelant to the network below:</span>
        <span class="c1">#</span>
        <span class="c1">#  p1   --------- Y_3 ---------- p2 </span>
        <span class="c1">#           |               |</span>
        <span class="c1">#          Y_1             Y_2</span>
        <span class="c1">#           |               |</span>
        <span class="c1">#  gr   ------------------------ gr</span>
        <span class="c1"># Note that the transfer function is independant of Y_1, this in essence </span>
        <span class="c1"># a voltage divider (see https://en.wikipedia.org/wiki/Voltage_divider)</span>
        <span class="c1"># where the voltage at p2 is entirely determined by Y_2,Y_3 and the voltage at p1</span>


            <span class="k">if</span> <span class="n">node_left_minus</span> <span class="o">==</span> <span class="n">node_right_minus</span><span class="p">:</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">node_left_plus</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">node_right_plus</span>
                <span class="n">gr</span> <span class="o">=</span> <span class="n">node_left_minus</span> <span class="c1">#= node_right_minus</span>
                <span class="c1"># Y_1 = ntr.branch_admittance(p1,gr)</span>
                <span class="n">Y_2</span> <span class="o">=</span> <span class="n">ntr</span><span class="o">.</span><span class="n">branch_admittance</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span><span class="n">gr</span><span class="p">)</span>
                <span class="n">Y_3</span> <span class="o">=</span> <span class="n">ntr</span><span class="o">.</span><span class="n">branch_admittance</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>

                <span class="c1"># A component of the ABCD matrix</span>
                <span class="n">A</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="n">Y_2</span><span class="o">/</span><span class="n">Y_3</span> <span class="c1"># node Y_3 cannot be 0 in theory</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">A</span>

            <span class="k">elif</span> <span class="n">node_left_plus</span> <span class="o">==</span> <span class="n">node_right_plus</span><span class="p">:</span>
                <span class="c1"># Ports 1 and 2 are the wrong way round, minuses cancel out</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">node_left_minus</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">node_right_minus</span>
                <span class="n">gr</span> <span class="o">=</span> <span class="n">node_left_plus</span> <span class="c1">#= node_right_plus</span>

                <span class="c1"># Y_1 = ntr.branch_admittance(p1,gr)</span>
                <span class="n">Y_2</span> <span class="o">=</span> <span class="n">ntr</span><span class="o">.</span><span class="n">branch_admittance</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span><span class="n">gr</span><span class="p">)</span>
                <span class="n">Y_3</span> <span class="o">=</span> <span class="n">ntr</span><span class="o">.</span><span class="n">branch_admittance</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>

                <span class="c1"># A component of the ABCD matrix</span>
                <span class="n">A</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="n">Y_2</span><span class="o">/</span><span class="n">Y_3</span> <span class="c1"># node Y_3 cannot be 0 in theory</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">A</span>

            <span class="k">elif</span> <span class="n">node_left_minus</span> <span class="o">==</span> <span class="n">node_right_plus</span><span class="p">:</span>
                <span class="c1"># Port 2 is the wrong way round, transfer function gets a minus</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">node_left_plus</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">node_right_minus</span>
                <span class="n">gr</span> <span class="o">=</span> <span class="n">node_left_minus</span> <span class="c1">#= node_right_plus</span>
                <span class="c1"># Y_1 = ntr.branch_admittance(p1,gr)</span>
                <span class="n">Y_2</span> <span class="o">=</span> <span class="n">ntr</span><span class="o">.</span><span class="n">branch_admittance</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span><span class="n">gr</span><span class="p">)</span>
                <span class="n">Y_3</span> <span class="o">=</span> <span class="n">ntr</span><span class="o">.</span><span class="n">branch_admittance</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>

                <span class="c1"># A component of the ABCD matrix</span>
                <span class="n">A</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="n">Y_2</span><span class="o">/</span><span class="n">Y_3</span> <span class="c1"># node Y_3 cannot be 0 in theory</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">A</span>

            <span class="k">elif</span> <span class="n">node_left_plus</span> <span class="o">==</span> <span class="n">node_right_minus</span><span class="p">:</span>
                <span class="c1"># Port 2 is the wrong way round, transfer function gets a minus</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">node_left_minus</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">node_right_plus</span>
                <span class="n">gr</span> <span class="o">=</span> <span class="n">node_left_plus</span> <span class="c1">#= node_right_minus</span>
                <span class="c1"># Y_1 = ntr.branch_admittance(p1,gr)</span>
                <span class="n">Y_2</span> <span class="o">=</span> <span class="n">ntr</span><span class="o">.</span><span class="n">branch_admittance</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span><span class="n">gr</span><span class="p">)</span>
                <span class="n">Y_3</span> <span class="o">=</span> <span class="n">ntr</span><span class="o">.</span><span class="n">branch_admittance</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>

                <span class="c1"># A component of the ABCD matrix</span>
                <span class="n">A</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="n">Y_2</span><span class="o">/</span><span class="n">Y_3</span> <span class="c1"># node Y_3 cannot be 0 in theory</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">A</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Most complex case (discussed in the paper)</span>
            <span class="c1"># First, compute the impence matrix of the lattice network following notations in </span>
            <span class="c1"># https://www.globalspec.com/reference/71734/203279/10-11-lattice-networks</span>
            <span class="c1"># excerpt of Network Analysis &amp; Circuit (By M. Arshad) section 10.11: LATTICE NETWORKS</span>
            <span class="n">Ya</span> <span class="o">=</span> <span class="n">ntr</span><span class="o">.</span><span class="n">branch_admittance</span><span class="p">(</span><span class="n">node_left_plus</span><span class="p">,</span> <span class="n">node_right_plus</span><span class="p">)</span>
            <span class="n">Yb</span> <span class="o">=</span> <span class="n">ntr</span><span class="o">.</span><span class="n">branch_admittance</span><span class="p">(</span><span class="n">node_left_minus</span><span class="p">,</span> <span class="n">node_right_plus</span><span class="p">)</span>
            <span class="n">Yc</span> <span class="o">=</span> <span class="n">ntr</span><span class="o">.</span><span class="n">branch_admittance</span><span class="p">(</span><span class="n">node_left_plus</span><span class="p">,</span> <span class="n">node_right_minus</span><span class="p">)</span>
            <span class="n">Yd</span> <span class="o">=</span> <span class="n">ntr</span><span class="o">.</span><span class="n">branch_admittance</span><span class="p">(</span><span class="n">node_left_minus</span><span class="p">,</span> <span class="n">node_right_minus</span><span class="p">)</span>

            <span class="c1"># The book provides formulas with impedance:</span>
            <span class="c1"># sum_Z = Za + Zb + Zc + Zd</span>
            <span class="c1"># Z11 is V1/I1 (with V2=0)</span>
            <span class="c1"># Z11 = (Za+Zb)*(Zd+Zc)/sum_Z</span>
            <span class="c1"># Z21 is V1/I2 (with V2=0)</span>
            <span class="c1"># Z21 = (Zb*Zc-Za*Zd)/sum_Z</span>
            <span class="c1"># Z22 is V2/I2 (with V1=0)</span>
            <span class="c1"># Z22 = (Za+Zc)*(Zd+Zb)/sum_Z</span>

            <span class="c1"># From Pozar, we obtain the A and B components of the ABCD matrix of the lattice</span>
            <span class="c1"># The C and D components play no role in determining the transfer function</span>
            <span class="c1"># A_lattice = Z11/Z21</span>
            <span class="c1"># B_lattice = Z11*Z22/Z21-Z21</span>

            <span class="c1"># We will work with admittances, to deal in an easier</span>
            <span class="c1"># way with Yx = 0 (otherwise we would have to </span>
            <span class="c1"># distinguish many more cases)</span>

            <span class="c1"># Using Mathematica, we compute simplify the expressions for </span>
            <span class="c1"># A_lattice and B_lattice to:</span>
            
            <span class="n">A_lattice</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ya</span> <span class="o">+</span> <span class="n">Yb</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Yd</span> <span class="o">+</span> <span class="n">Yc</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">Ya</span><span class="o">*</span><span class="n">Yd</span><span class="o">-</span><span class="n">Yb</span><span class="o">*</span><span class="n">Yc</span><span class="p">)</span>
            <span class="n">B_lattice</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ya</span> <span class="o">+</span> <span class="n">Yb</span> <span class="o">+</span> <span class="n">Yc</span> <span class="o">+</span> <span class="n">Yd</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">Ya</span><span class="o">*</span><span class="n">Yd</span><span class="o">-</span><span class="n">Yb</span><span class="o">*</span><span class="n">Yc</span><span class="p">)</span>

            <span class="c1"># The admittance accross the left port plays no role</span>
            <span class="c1"># The admittance accross the right port comes into play to yield the A component</span>
            <span class="c1"># of the total ABCD matrix:</span>

            <span class="n">A</span> <span class="o">=</span> <span class="n">A_lattice</span> <span class="o">+</span> <span class="n">B_lattice</span><span class="o">*</span><span class="n">ntr</span><span class="o">.</span><span class="n">branch_admittance</span><span class="p">(</span><span class="n">node_right_minus</span><span class="p">,</span><span class="n">node_right_plus</span><span class="p">)</span>

            <span class="k">return</span>  <span class="mi">1</span><span class="o">/</span><span class="n">A</span>

<span class="k">class</span> <span class="nc">Circuit</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;docstring for Circuit&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_minus</span><span class="p">,</span> <span class="n">node_plus</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_minus</span> <span class="o">=</span> <span class="n">node_minus</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_plus</span> <span class="o">=</span> <span class="n">node_plus</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_circuit</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Parallel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_circuit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_plot_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_node_minus</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_minus_plot</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_node_plus</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_plus_plot</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_plot_node_minus</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_minus_plot</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_plot_node_plus</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_plus_plot</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_center</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_plot_node_minus</span> <span class="o">+</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_node_plus</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_plot_center</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_plot_node_minus</span> <span class="o">+</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">y_plot_node_plus</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_node_minus</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_node_plus</span><span class="p">:</span>
            <span class="c1"># increasing y = SOUTH in tkinter</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_plot_node_minus</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_plot_node_plus</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="n">SOUTH</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="n">NORTH</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_node_minus</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_node_plus</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="n">WEST</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="n">EAST</span>

    <span class="k">def</span> <span class="nf">_draw_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">_pp</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="o">%</span><span class="mf">180.</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_center</span><span class="o">+</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">][</span><span class="s1">&#39;text_position_horizontal&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_plot_center</span><span class="o">+</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">][</span><span class="s1">&#39;text_position_horizontal&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ha</span> <span class="o">=</span> <span class="s1">&#39;center&#39;</span>
            <span class="n">va</span> <span class="o">=</span> <span class="s1">&#39;top&#39;</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_center</span><span class="o">+</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">][</span><span class="s1">&#39;text_position_vertical&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_plot_center</span><span class="o">+</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">][</span><span class="s1">&#39;text_position_vertical&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ha</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span>
            <span class="n">va</span> <span class="o">=</span> <span class="s1">&#39;center&#39;</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
                <span class="n">to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">),</span>
                <span class="n">fontsize</span><span class="o">=</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">][</span><span class="s1">&#39;fontsize&#39;</span><span class="p">],</span>
                <span class="n">ha</span><span class="o">=</span><span class="n">ha</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="n">va</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Parallel</span><span class="p">(</span><span class="n">Circuit</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Parallel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node_minus</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node_plus</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># sets the two children circuit elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

    <span class="k">def</span> <span class="nf">_admittance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">_admittance</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">_admittance</span><span class="p">())</span>
    
    <span class="k">def</span> <span class="nf">_get_RLC_matrix_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">RLC_matrix_components</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;R&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;L&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;C&#39;</span><span class="p">:</span><span class="mi">0</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">]:</span>
            <span class="n">values_to_add</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">_get_RLC_matrix_components</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">RLC_matrix_components</span><span class="p">:</span>
                <span class="n">RLC_matrix_components</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">values_to_add</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">RLC_matrix_components</span>

<span class="k">class</span> <span class="nc">Component</span><span class="p">(</span><span class="n">Circuit</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_minus</span><span class="p">,</span> <span class="n">node_plus</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Component</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node_minus</span><span class="p">,</span> <span class="n">node_plus</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__flux</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Specify either a value or a label&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">a</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">a</span>

                <span class="c1"># Check its not too big, too small, or negative</span>
                <span class="c1"># Note that values above max(min)_float would then</span>
                <span class="c1"># be interpreted as infinity (or zero)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">&gt;</span><span class="n">max_float</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Maximum allowed value is </span><span class="si">%.2e</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">max_float</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Value should be a positive float&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">&lt;</span><span class="n">min_float</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Minimum allowed value is </span><span class="si">%.2e</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">min_float</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">kwargs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_component_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">_no_value_components</span><span class="p">:</span>
                <span class="c1"># raise ValueError(</span>
                <span class="c1">#     &quot;Two components may not have the same name %s&quot; % self.label)</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">_no_value_components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_flux_zpf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">_set_zeta</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">zeta</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">_flux_transformation_dict</span><span class="p">[</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">ref_elt</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">.</span><span class="n">node_minus</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">ref_elt</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">.</span><span class="n">node_plus</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">node_minus</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">node_plus</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">tr_analytical</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">_network</span><span class="o">.</span><span class="n">transfer</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">ref_elt</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">.</span><span class="n">node_minus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">ref_elt</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">.</span><span class="n">node_plus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_minus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_plus</span><span class="p">)</span>
            <span class="n">tr</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">([</span><span class="s1">&#39;w&#39;</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">_no_value_components</span><span class="p">,</span><span class="n">tr_analytical</span><span class="p">,</span> <span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">tr_minus</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">tr</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">_flux_transformation_dict</span><span class="p">[</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">ref_elt</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">.</span><span class="n">node_minus</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">ref_elt</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">.</span><span class="n">node_plus</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">node_minus</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">node_plus</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">_flux_transformation_dict</span><span class="p">[</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">ref_elt</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">.</span><span class="n">node_minus</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">ref_elt</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">.</span><span class="n">node_plus</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">node_plus</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">node_minus</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr_minus</span>

        <span class="c1"># Following Black-box quantization, </span>
        <span class="c1"># we assume the losses to be neglegible by </span>
        <span class="c1"># removing the imaginary part of the eigenfrequency</span>
        <span class="c1"># w = np.real(w)</span>
        
        <span class="c1"># Calculation of phi_zpf of the reference junction/inductor</span>
        <span class="c1">#  = sqrt(hbar/w/ImdY[w])</span>
        <span class="c1"># The minus is there since 1/Im(Y)  = -Im(1/Y)</span>
        <span class="n">phi_zpf_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">ref_elt</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">.</span><span class="n">_flux_zpf_r</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Note that the flux defined here </span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">tr</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">*</span><span class="n">phi_zpf_r</span>
        <span class="c1"># is complex.</span>

        <span class="k">return</span> <span class="n">phi</span>


    <span class="k">def</span> <span class="nf">_to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">use_unicode</span><span class="o">=</span><span class="n">use_unicode</span><span class="p">)</span>


    <span class="nd">@vectorize_kwargs</span><span class="p">(</span><span class="n">exclude</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;quantity&#39;</span><span class="p">,</span><span class="s1">&#39;mode&#39;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">zpf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&#39;&#39;&#39;Returns contribution of a mode to the zero-point fluctuations of a quantity for this component.</span>

<span class="sd">        The quantity can be current (in units of Ampere), </span>
<span class="sd">        voltage (in Volts), </span>
<span class="sd">        charge (in electron charge), </span>
<span class="sd">        or flux (in units of the reduced flux quantum, :math:`\hbar/2e`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode:           integer</span>
<span class="sd">                        Determine what mode to consider, where 0 designates</span>
<span class="sd">                        the lowest frequency mode, and the others</span>
<span class="sd">                        are arranged in order of increasing frequency</span>
<span class="sd">        quantity:       string</span>
<span class="sd">                        One of &#39;current&#39;, &#39;flux&#39;, &#39;charge&#39;, &#39;voltage&#39;</span>
<span class="sd">        kwargs:     </span>
<span class="sd">                    Values for un-specified circuit components, </span>
<span class="sd">                    ex: ``L=1e-9``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            contribution of the ``mode`` to the zero-point fluctuations of the ``quantity``</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This quantity is calculated by multiplying the</span>
<span class="sd">        voltage transfer function :math:`T_{rc}` (between a reference component :math:`r`</span>
<span class="sd">        and the annotated component  :math:`c` ), with</span>
<span class="sd">        :math:`X_{zpf,m,r}`, the zero-point fluctuations of :math:`\hat{X}` at the reference component.</span>
<span class="sd">        </span>
<span class="sd">        Note that resistors make the transfer function :math:`T_{rc}`, and hence this quantity, complex.</span>

<span class="sd">        For more detail on the underlying theory, see https://arxiv.org/pdf/1908.10342.pdf.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">quantity</span> <span class="o">==</span> <span class="s1">&#39;flux&#39;</span><span class="p">:</span>
            <span class="n">phi_0</span> <span class="o">=</span> <span class="n">hbar</span><span class="o">/</span><span class="mf">2.</span><span class="o">/</span><span class="n">e</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux_zpf</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">/</span><span class="n">phi_0</span>
        <span class="k">if</span> <span class="n">quantity</span> <span class="o">==</span> <span class="s1">&#39;voltage&#39;</span><span class="p">:</span>
            <span class="n">phi_zpf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux_zpf</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># The above will set the eigenfrequencies</span>
            <span class="n">w</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">zeta</span><span class="p">)[</span><span class="n">mode</span><span class="p">]</span>
            
            <span class="k">return</span> <span class="n">phi_zpf</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">w</span>
        <span class="k">if</span> <span class="n">quantity</span> <span class="o">==</span> <span class="s1">&#39;current&#39;</span><span class="p">:</span>
            <span class="n">Vzpf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zpf</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span><span class="s1">&#39;voltage&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># The above will set the eigenfrequencies</span>

            <span class="n">kwargs_with_w</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">kwargs_with_w</span><span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">zeta</span><span class="p">)[</span><span class="n">mode</span><span class="p">]</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_admittance</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">Number</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">subs</span><span class="o">=</span><span class="n">kwargs_with_w</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="n">Vzpf</span><span class="o">*</span><span class="n">Y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">quantity</span> <span class="o">==</span> <span class="s1">&#39;charge&#39;</span><span class="p">:</span>
            <span class="n">Izpf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zpf</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span><span class="s1">&#39;current&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># The above will set the eigenfrequencies</span>

            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">zeta</span><span class="p">)[</span><span class="n">mode</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">Izpf</span><span class="o">/</span><span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="n">w</span><span class="o">/</span><span class="n">e</span>

<span class="k">class</span> <span class="nc">W</span><span class="p">(</span><span class="n">Component</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;docstring for Wire&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_minus</span><span class="p">,</span> <span class="n">node_plus</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node_minus</span><span class="p">,</span> <span class="n">node_plus</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_to_string</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39; &#39;</span>

    <span class="k">def</span> <span class="nf">_set_component_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_set_component_lists</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">_wire</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_draw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">_pp</span>

        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">x_plot_node_minus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_node_plus</span><span class="p">]),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">x_plot_node_minus</span><span class="p">]),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">x_plot_node_plus</span><span class="p">])]</span>

        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">y_plot_node_minus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_plot_node_plus</span><span class="p">]),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">y_plot_node_minus</span><span class="p">]),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">y_plot_node_plus</span><span class="p">])]</span>

        <span class="n">line_type</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;W&#39;</span><span class="p">]</span>
        <span class="n">line_type</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;node&#39;</span><span class="p">]</span>
        <span class="n">line_type</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;node&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">line_type</span>

<span class="k">class</span> <span class="nc">G</span><span class="p">(</span><span class="n">W</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    From a network perspective, a ground element is a wire that connects</span>
<span class="sd">    node_plus to a node called &#39;__ground&#39;</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_minus</span><span class="p">,</span> <span class="n">node_plus</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node_minus</span><span class="p">,</span> <span class="n">node_plus</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_component_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_set_component_lists</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">_grounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_draw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">_pp</span>
        <span class="c1"># Defined for EAST</span>
        <span class="n">line_type</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.23</span><span class="p">,</span> <span class="mf">0.23</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.16</span><span class="p">,</span> <span class="mf">0.16</span><span class="p">]),</span>
        <span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span><span class="o">*</span><span class="mf">5.</span><span class="o">/</span><span class="mf">30.</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span><span class="o">*</span><span class="mf">3.</span><span class="o">/</span><span class="mf">30.</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span><span class="o">*</span><span class="mf">1.</span><span class="o">/</span><span class="mf">30.</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">line_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;W&#39;</span><span class="p">)</span>
        <span class="n">line_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;W&#39;</span><span class="p">)</span>
        <span class="n">line_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;W&#39;</span><span class="p">)</span>
        <span class="n">line_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;W&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">==</span> <span class="n">WEST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_center</span><span class="p">),</span> <span class="n">shift</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_plot_center</span><span class="p">),</span> <span class="n">line_type</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">==</span> <span class="n">NORTH</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">shift</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_center</span><span class="p">),</span> <span class="n">shift</span><span class="p">([</span><span class="o">-</span><span class="n">xx</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="n">x</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_plot_center</span><span class="p">),</span> <span class="n">line_type</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">==</span> <span class="n">EAST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">shift</span><span class="p">([</span><span class="o">-</span><span class="n">xx</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="n">x</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_center</span><span class="p">),</span> <span class="n">shift</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_plot_center</span><span class="p">),</span> <span class="n">line_type</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">==</span> <span class="n">SOUTH</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">shift</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_center</span><span class="p">),</span> <span class="n">shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_plot_center</span><span class="p">),</span> <span class="n">line_type</span>

<div class="viewcode-block" id="L">
<a class="viewcode-back" href="../../API/components/L.html#qucat.L">[docs]</a>
<span class="k">class</span> <span class="nc">L</span><span class="p">(</span><span class="n">Component</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class representing an inductor</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    node_minus:     integer</span>
<span class="sd">                    Index corresponding to one node of inductor</span>
<span class="sd">    node_minus:     integer</span>
<span class="sd">                    Index corresponding to the other node of the inductor</span>
<span class="sd">    args:           &lt;float&gt; or &lt;str&gt; or &lt;float&gt;,&lt;str&gt;</span>
<span class="sd">                    Other arguments should be a float corresponding to the</span>
<span class="sd">                    inductance, a string corresponding to the </span>
<span class="sd">                    name of that value (ex: `&quot;L&quot;`), or both.</span>
<span class="sd">                    If only a label is provided, </span>
<span class="sd">                    a value for should be passed</span>
<span class="sd">                    as a keyword argument in subsequent function calls</span>
<span class="sd">                    (ex: `L = 1e-9`)   </span>
<span class="sd">                    This is the best way to proceed if one wants to sweep the value of this</span>
<span class="sd">                    inductor. Indeed, the most computationally expensive part of the </span>
<span class="sd">                    analysis is performed upon initializing the circuit, subsequently</span>
<span class="sd">                    changing the value of a component and re-calculating a quantity </span>
<span class="sd">                    such as the frequency or anharmonicity can be performed much faster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_minus</span><span class="p">,</span> <span class="n">node_plus</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node_minus</span><span class="p">,</span> <span class="n">node_plus</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;H&#39;</span>

    <span class="k">def</span> <span class="nf">_admittance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">sp</span><span class="o">.</span><span class="n">I</span><span class="o">*</span><span class="n">Mul</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">),</span> <span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_value</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_set_component_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_set_component_lists</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">inductors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_draw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">_pp</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span>
            <span class="n">pp</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">][</span><span class="s1">&#39;N_turns&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">pp</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">][</span><span class="s1">&#39;N_points&#39;</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">x</span>

        <span class="n">line_type</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">line_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">)</span>

        <span class="c1"># reset leftmost point to 0</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">-=</span> <span class="n">x_min</span>

        <span class="c1"># set width inductor width</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">*=</span> <span class="n">pp</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">][</span><span class="s1">&#39;width&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">x_max</span>

        <span class="c1"># set leftmost point to the length of</span>
        <span class="c1"># the side connection wires</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">][</span><span class="s1">&#39;width&#39;</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span>

        <span class="c1"># add side wire connections</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="n">x_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="n">x_min</span><span class="p">])]</span>
        <span class="n">x_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_max</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])]</span>
        <span class="n">line_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;W&#39;</span><span class="p">)</span>
        <span class="n">line_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;W&#39;</span><span class="p">)</span>

        <span class="c1"># center in x</span>
        <span class="n">x_list</span> <span class="o">=</span> <span class="n">shift</span><span class="p">(</span><span class="n">x_list</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>

        <span class="c1"># set height of inductor</span>
        <span class="n">y</span> <span class="o">*=</span> <span class="n">pp</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">][</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span>

        <span class="c1"># add side wire connections</span>
        <span class="n">y_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">]</span>
        <span class="n">y_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])]</span>
        <span class="n">y_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="o">%</span><span class="mf">180.</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">shift</span><span class="p">(</span><span class="n">x_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_center</span><span class="p">),</span> <span class="n">shift</span><span class="p">(</span><span class="n">y_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_plot_center</span><span class="p">),</span> <span class="n">line_type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="o">%</span><span class="mf">180.</span> <span class="o">==</span> <span class="mf">90.</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">shift</span><span class="p">(</span><span class="n">y_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_center</span><span class="p">),</span> <span class="n">shift</span><span class="p">(</span><span class="n">x_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_plot_center</span><span class="p">),</span> <span class="n">line_type</span>

    <span class="k">def</span> <span class="nf">_get_RLC_matrix_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;R&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;L&#39;</span><span class="p">:</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_value</span><span class="p">(),</span>
            <span class="s1">&#39;C&#39;</span><span class="p">:</span><span class="mi">0</span>
        <span class="p">}</span>

    <span class="nd">@timeit</span>
    <span class="k">def</span> <span class="nf">_compute_flux_zpf_r</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Generate the L._flux_zpf_r function which</span>
<span class="sd">        takes as an argument an angular frequency (and keyword arguments </span>
<span class="sd">        if component values need to be specified) and returns the </span>
<span class="sd">        derivative of the admittance evaluated at the nodes of the inductor, </span>
<span class="sd">        which is effective capacitance at that frequency.         </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Compute a sympy expression for the admittance </span>
        <span class="c1"># at the nodes of the reference element</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">_network</span><span class="o">.</span><span class="n">admittance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_minus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_plus</span><span class="p">)</span>

        <span class="c1"># Write the expression as a single fraction </span>
        <span class="c1"># with the numerator and denomenator as polynomials</span>
        <span class="c1"># (it combines but also &quot;de-nests&quot;)      </span>
        <span class="n">Y_together</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">together</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>

        <span class="c1"># Extract numerator and denominator</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">numer</span><span class="p">(</span><span class="n">Y_together</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">denom</span><span class="p">(</span><span class="n">Y_together</span><span class="p">)</span>

        <span class="c1"># Symbol representing angular frequency</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>

        <span class="c1"># Calculate derivatives</span>
        <span class="n">derivatives</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="p">[</span><span class="n">u</span><span class="p">]:</span><span class="c1">#[u,v]:</span>
            <span class="c1"># Write as polynomial in &#39;w&#39;</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">P</span><span class="p">),</span> <span class="n">w</span><span class="p">)</span>

            <span class="c1"># Obtain the order of the polynomial </span>
            <span class="n">P_order</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">polys</span><span class="o">.</span><span class="n">polytools</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">gen</span><span class="o">=</span><span class="n">w</span><span class="p">)</span> 

            <span class="c1"># Compute list of coefficients</span>
            <span class="n">P_coeffs_analytical</span> <span class="o">=</span> <span class="p">[</span><span class="n">P</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">P_order</span><span class="o">+</span><span class="mi">1</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

            <span class="c1"># Express the derivative of the polynomial</span>
            <span class="n">dP</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([(</span><span class="n">P_order</span><span class="o">-</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="p">(</span><span class="n">P_order</span><span class="o">-</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">P_coeffs_analytical</span><span class="p">)])</span>

            <span class="n">derivatives</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dP</span><span class="p">)</span>
        
        <span class="n">du</span> <span class="o">=</span> <span class="n">derivatives</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># dv = derivatives[1]</span>
        
        <span class="c1"># Convert the sympy expression for v/du to a function</span>
        <span class="c1"># Note the function arguments are the angular frequency </span>
        <span class="c1"># and component values that need to be specified</span>
        <span class="n">dY</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">([</span><span class="s1">&#39;w&#39;</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">_no_value_components</span><span class="p">,</span><span class="n">du</span><span class="o">/</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;numpy&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_flux_zpf_r</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">hbar</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">dY</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_flux_zpf_r</span> <span class="o">=</span> <span class="n">_flux_zpf_r</span></div>



<div class="viewcode-block" id="J">
<a class="viewcode-back" href="../../API/components/J.html#qucat.J">[docs]</a>
<span class="k">class</span> <span class="nc">J</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class representing a junction</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    node_minus:     integer</span>
<span class="sd">                    Index corresponding to one node of junction</span>
<span class="sd">    node_minus:     integer</span>
<span class="sd">                    Index corresponding to the other node of the junction</span>
<span class="sd">    args:           &lt;float&gt; or &lt;str&gt; or &lt;float&gt;,&lt;str&gt;</span>
<span class="sd">                    Other arguments should be a float which by default</span>
<span class="sd">                    corresponds to the Josephson inductance of the</span>
<span class="sd">                    junction, a string corresponding to the </span>
<span class="sd">                    name of that value (ex: `&quot;L_J&quot;`), or both.</span>
<span class="sd">                    If only a label is provided, </span>
<span class="sd">                    a value for this junction should be passed</span>
<span class="sd">                    as a keyword argument in subsequent function calls</span>
<span class="sd">                    (ex: `L_J = 10e-9`).</span>
<span class="sd">                    This is the best way to proceed if one wants to sweep the value of this</span>
<span class="sd">                    junction. Indeed, the most computationally expensive part of the </span>
<span class="sd">                    analysis is performed upon initializing the circuit, subsequently</span>
<span class="sd">                    changing the value of a component and re-calculating a quantity </span>
<span class="sd">                    such as the frequency or anharmonicity can be performed much faster.</span>
<span class="sd">    use_E:          Boolean</span>
<span class="sd">                    If set to True, the junction will be parametrized by</span>
<span class="sd">                    its Josephson energy, given in units of Hertz, rather</span>
<span class="sd">                    than its Josephson inductance</span>
<span class="sd">    use_I:          Boolean</span>
<span class="sd">                    If set to True, the junction will be parametrized by</span>
<span class="sd">                    its critical current, given in units of Ampere, rather</span>
<span class="sd">                    than its Josephson inductance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_minus</span><span class="p">,</span> <span class="n">node_plus</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">use_E</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_I</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node_minus</span><span class="p">,</span> <span class="n">node_plus</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">use_E</span> <span class="o">=</span> <span class="n">use_E</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_I</span> <span class="o">=</span> <span class="n">use_I</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_E</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;Hz&#39;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_I</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;A&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;H&#39;</span>

    <span class="k">def</span> <span class="nf">_get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Returns the Josephson inductance</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_get_value</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">use_E</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">use_I</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">use_E</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">use_I</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">hbar</span><span class="o">/</span><span class="mf">2.</span><span class="o">/</span><span class="n">e</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">value</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>  <span class="c1"># E is assumed to be provided in Hz</span>
            <span class="k">return</span> <span class="n">L</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">use_E</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">use_I</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">hbar</span><span class="o">/</span><span class="mf">2.</span><span class="o">/</span><span class="n">e</span><span class="p">)</span><span class="o">/</span><span class="n">value</span>
            <span class="k">return</span> <span class="n">L</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot set both use_E and use_I to True&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_Ej</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">hbar</span><span class="o">/</span><span class="mf">2.</span><span class="o">/</span><span class="n">e</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_value</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_component_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_set_component_lists</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">junctions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
<div class="viewcode-block" id="J.anharmonicity">
<a class="viewcode-back" href="../../API/components/J.html#qucat.J.anharmonicity">[docs]</a>
    <span class="nd">@vectorize_kwargs</span><span class="p">(</span><span class="n">exclude</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">anharmonicity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&#39;&#39;&#39;Returns the contribution of this junction to the anharmonicity of a given normal mode.</span>

<span class="sd">        Returned in units of Hertz, not angular frequency.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs:     </span>
<span class="sd">                    Values for un-specified circuit components, </span>
<span class="sd">                    ex: ``L=1e-9``.</span>
<span class="sd">        </span>
<span class="sd">        mode:           integer</span>
<span class="sd">                        where 0 designates</span>
<span class="sd">                        the lowest frequency mode, and the others</span>
<span class="sd">                        are arranged in order of increasing frequency</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            contribution of this junction to the anharmonicity of a given normal mode</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The quantity returned is the anharmonicity</span>
<span class="sd">        of the mode ``m`` if this junction were the only junction</span>
<span class="sd">        present in the circuit (i.e. if all the </span>
<span class="sd">        others were replaced by linear inductors).</span>

<span class="sd">        The total anharmonicity of a mode (in first order perturbation theory) is obtained</span>
<span class="sd">        by summing these contribution over all modes.</span>

<span class="sd">        For more details, see https://arxiv.org/pdf/1908.10342.pdf</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_Ej</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zpf</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span><span class="n">quantity</span><span class="o">=</span><span class="s1">&#39;flux&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span><span class="o">**</span><span class="mi">4</span></div>



    <span class="k">def</span> <span class="nf">_draw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">_pp</span>

        <span class="n">line_type</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mf">1.</span><span class="o">-</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;J&#39;</span><span class="p">][</span><span class="s1">&#39;width&#39;</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span>
                      <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;J&#39;</span><span class="p">][</span><span class="s1">&#39;width&#39;</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mf">1.</span><span class="o">-</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;J&#39;</span><span class="p">][</span><span class="s1">&#39;width&#39;</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span>
                      <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;J&#39;</span><span class="p">][</span><span class="s1">&#39;width&#39;</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">])</span>
        <span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span><span class="o">*</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;J&#39;</span><span class="p">][</span><span class="s1">&#39;width&#39;</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">])</span><span class="o">*</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;J&#39;</span><span class="p">][</span><span class="s1">&#39;width&#39;</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span>
        <span class="p">]</span>
        <span class="n">line_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;W&#39;</span><span class="p">)</span>
        <span class="n">line_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">)</span>
        <span class="n">line_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">)</span>

        <span class="c1"># center in x and y</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="o">%</span><span class="mf">180.</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_center</span><span class="p">),</span> <span class="n">shift</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_plot_center</span><span class="p">),</span> <span class="n">line_type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="o">%</span><span class="mf">180.</span> <span class="o">==</span> <span class="mf">90.</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">shift</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_center</span><span class="p">),</span> <span class="n">shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_plot_center</span><span class="p">),</span> <span class="n">line_type</span></div>


<div class="viewcode-block" id="R">
<a class="viewcode-back" href="../../API/components/R.html#qucat.R">[docs]</a>
<span class="k">class</span> <span class="nc">R</span><span class="p">(</span><span class="n">Component</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class representing a resistor</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    node_minus:     integer</span>
<span class="sd">                    Index corresponding to one node of resistor</span>
<span class="sd">    node_minus:     integer</span>
<span class="sd">                    Index corresponding to the other node of the resistor</span>
<span class="sd">    args:           &lt;float&gt; or &lt;str&gt; or &lt;float&gt;,&lt;str&gt;</span>
<span class="sd">                    Other arguments should be a float corresponding to the</span>
<span class="sd">                    resistance, a string corresponding to the </span>
<span class="sd">                    name of that value (ex: `&quot;R&quot;`), or both.</span>
<span class="sd">                    If only a label is provided, </span>
<span class="sd">                    a value for should be passed</span>
<span class="sd">                    as a keyword argument in subsequent function calls</span>
<span class="sd">                    (ex: `R = 1e-9`)   </span>
<span class="sd">                    This is the best way to proceed if one wants to sweep the value of this</span>
<span class="sd">                    resistor. Indeed, the most computationally expensive part of the </span>
<span class="sd">                    analysis is performed upon initializing the circuit, subsequently</span>
<span class="sd">                    changing the value of a component and re-calculating a quantity </span>
<span class="sd">                    such as the dissipation rate can be performed much faster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_minus</span><span class="p">,</span> <span class="n">node_plus</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node_minus</span><span class="p">,</span> <span class="n">node_plus</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="sa">u</span><span class="s2">&quot;</span><span class="se">\u03A9</span><span class="s2">&quot;</span>

    <span class="k">def</span> <span class="nf">_admittance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_value</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">_set_component_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_set_component_lists</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">resistors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_get_RLC_matrix_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;R&#39;</span><span class="p">:</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_value</span><span class="p">(),</span>
            <span class="s1">&#39;L&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;C&#39;</span><span class="p">:</span><span class="mi">0</span>
        <span class="p">}</span>
    
    <span class="k">def</span> <span class="nf">_draw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">_pp</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span> <span class="o">+</span><span class="nb">float</span><span class="p">(</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">][</span><span class="s1">&#39;N_ridges&#39;</span><span class="p">]),</span> <span class="n">pp</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">][</span><span class="s1">&#39;N_points&#39;</span><span class="p">])</span>
        <span class="n">height</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="n">period</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">height</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">period</span><span class="p">),</span> <span class="mf">2.</span><span class="p">))</span>
        <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="n">height</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">period</span><span class="p">),</span> <span class="mf">2.</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">period</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">period</span><span class="p">))</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">height</span>

        <span class="n">line_type</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">line_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>

        <span class="c1"># reset leftmost point to 0</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">-=</span> <span class="n">x_min</span>

        <span class="c1"># set width inductor width</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">*=</span> <span class="n">pp</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">][</span><span class="s1">&#39;width&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">x_max</span>

        <span class="c1"># set leftmost point to the length of</span>
        <span class="c1"># the side connection wires</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">][</span><span class="s1">&#39;width&#39;</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span>

        <span class="c1"># add side wire connections</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="n">x_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="n">x_min</span><span class="p">])]</span>
        <span class="n">x_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_max</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])]</span>
        <span class="n">line_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;W&#39;</span><span class="p">)</span>
        <span class="n">line_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;W&#39;</span><span class="p">)</span>

        <span class="c1"># center in x</span>
        <span class="n">x_list</span> <span class="o">=</span> <span class="n">shift</span><span class="p">(</span><span class="n">x_list</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>

        <span class="c1"># set height of inductor</span>
        <span class="n">y</span> <span class="o">*=</span> <span class="n">pp</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">][</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span>

        <span class="c1"># add side wire connections</span>
        <span class="n">y_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">]</span>
        <span class="n">y_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])]</span>
        <span class="n">y_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="o">%</span><span class="mf">180.</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">shift</span><span class="p">(</span><span class="n">x_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_center</span><span class="p">),</span> <span class="n">shift</span><span class="p">(</span><span class="n">y_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_plot_center</span><span class="p">),</span> <span class="n">line_type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="o">%</span><span class="mf">180.</span> <span class="o">==</span> <span class="mf">90.</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">shift</span><span class="p">(</span><span class="n">y_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_center</span><span class="p">),</span> <span class="n">shift</span><span class="p">(</span><span class="n">x_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_plot_center</span><span class="p">),</span> <span class="n">line_type</span></div>


<div class="viewcode-block" id="C">
<a class="viewcode-back" href="../../API/components/C.html#qucat.C">[docs]</a>
<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">Component</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class representing a capacitor</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    node_minus:     integer</span>
<span class="sd">                    Index corresponding to one node of capacitor</span>
<span class="sd">    node_minus:     integer</span>
<span class="sd">                    Index corresponding to the other node of the capacitor</span>
<span class="sd">    args:           &lt;float&gt; or &lt;str&gt; or &lt;float&gt;,&lt;str&gt;</span>
<span class="sd">                    Other arguments should be a float corresponding to the</span>
<span class="sd">                    capacitance, a string corresponding to the </span>
<span class="sd">                    name of that value (ex: `&quot;C&quot;`), or both.</span>
<span class="sd">                    If only a label is provided, </span>
<span class="sd">                    a value for should be passed</span>
<span class="sd">                    as a keyword argument in subsequent function calls</span>
<span class="sd">                    (ex: `C = 1e-9`)   </span>
<span class="sd">                    This is the best way to proceed if one wants to sweep the value of this</span>
<span class="sd">                    capacitor. Indeed, the most computationally expensive part of the </span>
<span class="sd">                    analysis is performed upon initializing the circuit, subsequently</span>
<span class="sd">                    changing the value of a component and re-calculating a quantity </span>
<span class="sd">                    such as the anharmonicity can be performed much faster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_minus</span><span class="p">,</span> <span class="n">node_plus</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node_minus</span><span class="p">,</span> <span class="n">node_plus</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span>

    <span class="k">def</span> <span class="nf">_admittance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sp</span><span class="o">.</span><span class="n">I</span><span class="o">*</span><span class="n">Mul</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_value</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_set_component_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_set_component_lists</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">capacitors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_draw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">_pp</span>
        <span class="n">line_type</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">][</span><span class="s1">&#39;gap&#39;</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mf">1.</span><span class="o">+</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">][</span><span class="s1">&#39;gap&#39;</span><span class="p">])</span> <span class="o">/</span>
                      <span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mf">1.</span><span class="o">-</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">][</span><span class="s1">&#39;gap&#39;</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span>
                      <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">][</span><span class="s1">&#39;gap&#39;</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mf">1.</span><span class="o">+</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">][</span><span class="s1">&#39;gap&#39;</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span>
                      <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">][</span><span class="s1">&#39;gap&#39;</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">]),</span>
        <span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">][</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="n">pp</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">][</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">pp</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">][</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="n">pp</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">][</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span><span class="p">]),</span>
        <span class="p">]</span>
        <span class="n">line_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;W&#39;</span><span class="p">)</span>
        <span class="n">line_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;W&#39;</span><span class="p">)</span>
        <span class="n">line_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="n">line_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

        <span class="c1"># center in x and y</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="o">%</span><span class="mf">180.</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_center</span><span class="p">),</span> <span class="n">shift</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_plot_center</span><span class="p">),</span> <span class="n">line_type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="o">%</span><span class="mf">180.</span> <span class="o">==</span> <span class="mf">90.</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">shift</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_plot_center</span><span class="p">),</span> <span class="n">shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_plot_center</span><span class="p">),</span> <span class="n">line_type</span>

    <span class="k">def</span> <span class="nf">_get_RLC_matrix_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;R&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;L&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;C&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_value</span><span class="p">()</span>
        <span class="p">}</span></div>


<span class="k">class</span> <span class="nc">Admittance</span><span class="p">(</span><span class="n">Component</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_minus</span><span class="p">,</span> <span class="n">node_plus</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_minus</span> <span class="o">=</span> <span class="n">node_minus</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_plus</span> <span class="o">=</span> <span class="n">node_plus</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span>

    <span class="k">def</span> <span class="nf">_admittance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, Mario Gely.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>